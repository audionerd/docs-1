"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[49656],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>u,mdx:()=>g,useMDXComponents:()=>m,withMDXComponents:()=>c});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var d=a.createContext({}),c=function(e){return function(t){var n=m(t.components);return a.createElement(e,o({},t,{components:n}))}},m=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=m(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=m(n),u=s,h=c["".concat(r,".").concat(u)]||c[u]||p[u]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},30834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var a=n(87462),s=(n(67294),n(3905));const o={title:"useState vs useReducer vs XState - Part 1: Modals",description:"Managing state at different levels of complexity is hard. This series of articles should help you make the right choices off the bat. Today we\u2019re starting with modals.",tags:["modal","react","useState","useReducer","xstate"],authors:["matt"],image:"/blog/2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals.png",slug:"2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals",date:new Date("2021-07-28T00:00:00.000Z")},r=void 0,i={permalink:"/blog/2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals/index.mdx",source:"@site/blog/2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals/index.mdx",title:"useState vs useReducer vs XState - Part 1: Modals",description:"Managing state at different levels of complexity is hard. This series of articles should help you make the right choices off the bat. Today we\u2019re starting with modals.",date:"2021-07-28T00:00:00.000Z",formattedDate:"July 28, 2021",tags:[{label:"modal",permalink:"/blog/tags/modal"},{label:"react",permalink:"/blog/tags/react"},{label:"useState",permalink:"/blog/tags/use-state"},{label:"useReducer",permalink:"/blog/tags/use-reducer"},{label:"xstate",permalink:"/blog/tags/xstate"}],readingTime:7.245,hasTruncateMarker:!0,authors:[{name:"Matt Pocock",title:"Stately Team",url:"https://github.com/mattpocock",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/matt.png",key:"matt"}],frontMatter:{title:"useState vs useReducer vs XState - Part 1: Modals",description:"Managing state at different levels of complexity is hard. This series of articles should help you make the right choices off the bat. Today we\u2019re starting with modals.",tags:["modal","react","useState","useReducer","xstate"],authors:["matt"],image:"/blog/2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals.png",slug:"2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals",date:"2021-07-28T00:00:00.000Z"},prevItem:{title:"Introduction to state machines and statecharts",permalink:"/blog/2021-10-02-intro-fsm-sc"},nextItem:{title:"How to manage global state with XState and React",permalink:"/blog/2021-05-27-global-state-xstate-react"}},l={authorsImageUrls:[void 0]},d=[{value:"useState",id:"usestate",level:2},{value:"useReducer",id:"usereducer",level:2},{value:"useMachine",id:"usemachine",level:2},{value:"Alert: requirements changing",id:"alert-requirements-changing",level:2},{value:"useState",id:"usestate-1",level:3},{value:"useReducer",id:"usereducer-1",level:3},{value:"useMachine",id:"usemachine-1",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:d};function m(e){let{components:t,...n}=e;return(0,s.mdx)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.mdx)("p",null,"Managing state at different levels of complexity is hard. Different tools make different trade-offs between readability, complexity and speed of development. The worst part is that as apps get more complex, it\u2019s easy to regret choices that were made early on."),(0,s.mdx)("p",null,"This series of articles should help you make the right choice off the bat. The plan is to cover a bunch of state use cases, starting with the simple and graduating to more complexity as we go. We\u2019ll see how easy they are to write, and also how they survive changing requirements."),(0,s.mdx)("p",null,"Today, we\u2019re starting with ",(0,s.mdx)("a",{parentName:"p",href:"https://material-ui.com/components/modal/"},"modals"),"."),(0,s.mdx)("h2",{id:"usestate"},"useState"),(0,s.mdx)("p",null,"For modals, the key piece of state is whether or not the modal is open. ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," lets us capture that single piece of state pretty succinctly."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-ts"},"const [isOpen, setIsOpen] = useState(false);\n\nconst open = () => {\n  setIsOpen(true);\n};\n\nconst close = () => {\n  setIsOpen(false);\n};\n\nconst toggle = () => {\n  setIsOpen(!isOpen);\n};\n")),(0,s.mdx)("p",null,"Highly readable, simple enough, fast to write, bug-proof. For a simple toggle like this, ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," is great."),(0,s.mdx)("h2",{id:"usereducer"},"useReducer"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-ts"},'const reducer = (state = { isOpen: false }, action) => {\n  switch (action.type) {\n    case "OPEN":\n      return {\n        isOpen: true,\n      };\n    case "CLOSE":\n      return {\n        isOpen: false,\n      };\n    case "TOGGLE":\n      return {\n        isOpen: !state.isOpen,\n      };\n    default:\n      return state;\n  }\n};\n\nconst [state, dispatch] = useReducer(reducer, { isOpen: false });\n\nconst open = () => {\n  dispatch({ type: "OPEN" });\n};\n\nconst close = () => {\n  dispatch({ type: "CLOSE" });\n};\n\nconst toggle = () => {\n  dispatch({ type: "TOGGLE" });\n};\n')),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"useReducer")," gives us a reducer, a powerful centralized spot in our code where we can visualise the changes happening. However, it took us quite a few more lines of code to reach the same result as ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState"),". For now, I\u2019d say ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," has the edge."),(0,s.mdx)("h2",{id:"usemachine"},"useMachine"),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"useMachine")," is a hook from XState, which allows us to use the power of state machines in our code. Let\u2019s see how it looks."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-ts"},'const machine = Machine({\n  id: "modalMachine",\n  initial: "closed",\n  states: {\n    closed: {\n      on: {\n        OPEN: {\n          target: "open",\n        },\n        TOGGLE: "open",\n      },\n    },\n    open: {\n      on: {\n        TOGGLE: "closed",\n        CLOSE: "closed",\n      },\n    },\n  },\n});\n\nconst [state, send] = useMachine(machine);\n\nconst open = () => {\n  send({ type: "OPEN" });\n};\n\nconst close = () => {\n  send({ type: "CLOSE" });\n};\n\nconst toggle = () => {\n  send({ type: "TOGGLE" });\n};\n')),(0,s.mdx)("p",null,(0,s.mdx)("em",{parentName:"p"},"You can see the state machine on the ",(0,s.mdx)("a",{parentName:"em",href:"https://xstate.js.org/viz/?gist=cf1578f5baa04cf9408ef6e48695f04c"},"XState visualiser here"),".")),(0,s.mdx)("p",null,"It\u2019s remarkably similar in structure to the reducer above. Similar amount of lines, nearly the same event handlers. The state machine takes the edge over the reducer because of being able to easily visualise its logic - that\u2019s something the reducer can\u2019t match."),(0,s.mdx)("p",null,"However, the ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," implementation still has the edge for me. The simplicity of execution, the elegance. It\u2019s hard to see how it could be beaten..."),(0,s.mdx)("h2",{id:"alert-requirements-changing"},"Alert: requirements changing"),(0,s.mdx)("p",null,"Oh no. Requirements have changed. Now, instead of immediately closing, the modal needs to animate out. This means we need to insert a third state, ",(0,s.mdx)("inlineCode",{parentName:"p"},"closing"),", which we automatically leave after 500ms. Let\u2019s see how our implementations hold up."),(0,s.mdx)("h3",{id:"usestate-1"},"useState"),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 1"),": Our initial ",(0,s.mdx)("inlineCode",{parentName:"p"},"isOpen")," boolean won't handle all the states we need it to any more. Let\u2019s change it to an enum: ",(0,s.mdx)("inlineCode",{parentName:"p"},"closed"),", ",(0,s.mdx)("inlineCode",{parentName:"p"},"closing")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"open"),"."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 2"),": ",(0,s.mdx)("inlineCode",{parentName:"p"},"isOpen")," is no longer a descriptive variable name, so we need to rename it to ",(0,s.mdx)("inlineCode",{parentName:"p"},"modalState")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"setModalState"),"."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 3"),": ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," doesn\u2019t handle async changes by itself, so we need to bring in ",(0,s.mdx)("inlineCode",{parentName:"p"},"useEffect")," to run a timeout when the state is in the ",(0,s.mdx)("inlineCode",{parentName:"p"},"closing")," state. We also need to clear the timeout if the state is no longer ",(0,s.mdx)("inlineCode",{parentName:"p"},"closing"),"."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 4"),": We need to change the toggle event handler to add logic to ensure it only triggers on the ",(0,s.mdx)("inlineCode",{parentName:"p"},"closed")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"open")," states. Toggles work great for booleans, but become much harder to manage with enums."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-ts"},'// Refactor 1, 2\nconst [modalState, setModalState] = useState("closed");\n\n// Refactor 3\nuseEffect(() => {\n  if (modalState === "closing") {\n    const timeout = setTimeout(() => {\n      setModalState("closed");\n    }, 500);\n    return () => {\n      clearTimeout(timeout);\n    };\n  }\n}, [modalState]);\n\n// Refactor 1, 2\nconst open = () => {\n  setModalState("open");\n};\n\n// Refactor 1, 2\nconst close = () => {\n  setModalState("closing");\n};\n\n// Refactor 1, 2, 4\nconst toggle = () => {\n  if (modalState === "closed") {\n    setModalState("open");\n  } else if (modalState === "open") {\n    setModalState("closing");\n  }\n};\n')),(0,s.mdx)("p",null,"Yuck. That was an enormous amount of refactoring to do just to add a simple, single requirement. On code that might be subject to changing requirements, think twice before using ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState"),"."),(0,s.mdx)("h3",{id:"usereducer-1"},"useReducer"),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 1"),": Same as above - we turn the ",(0,s.mdx)("inlineCode",{parentName:"p"},"isOpen")," boolean to the same enum."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 2"),": Same as above, ",(0,s.mdx)("inlineCode",{parentName:"p"},"isOpen")," is now improperly named, so we need to change it to ",(0,s.mdx)("inlineCode",{parentName:"p"},"status"),". This is changed in fewer places than ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState"),", but there are still some changes to make."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 3"),": The same as above, we use ",(0,s.mdx)("inlineCode",{parentName:"p"},"useEffect")," to manage the timeout. An additional wrinkle is that we need a new action type in the reducer, ",(0,s.mdx)("inlineCode",{parentName:"p"},"REPORT_ANIMATION_FINISHED"),", to cover this."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 4"),": The same as above, but instead of the logic being in the event handler, we can actually change the logic inside the reducer. This is a cleaner change, but is still similar in the amount of lines it produces."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-ts"},'// Refactor 1, 2\nconst reducer = (state = { status: "closed" }, action) => {\n  switch (action.type) {\n    // Refactor 2\n    case "OPEN":\n      return {\n        status: "open",\n      };\n    // Refactor 2\n    case "CLOSE":\n      return {\n        status: "closing",\n      };\n    // Refactor 3\n    case "REPORT_ANIMATION_FINISHED":\n      return {\n        status: "closed",\n      };\n    // Refactor 4\n    case "TOGGLE":\n      switch (state.status) {\n        case "closed":\n          return {\n            status: "open",\n          };\n        case "open":\n          return {\n            status: "closing",\n          };\n      }\n      break;\n    default:\n      return state;\n  }\n};\n\n// Refactor 1\nconst [state, dispatch] = useReducer(reducer, { status: "closed" });\n\n// Refactor 3\nuseEffect(() => {\n  if (state.status === "closing") {\n    const timeout = setTimeout(() => {\n      dispatch({ type: "REPORT_ANIMATION_FINISHED" });\n    }, 500);\n    return () => {\n      clearTimeout(timeout);\n    };\n  }\n}, [state.status]);\n\nconst open = () => {\n  dispatch({ type: "OPEN" });\n};\n\nconst close = () => {\n  dispatch({ type: "CLOSE" });\n};\n\nconst toggle = () => {\n  dispatch({ type: "TOGGLE" });\n};\n')),(0,s.mdx)("p",null,"This file required the same number of refactors as the ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," implementation. One crucial advantage is that these refactors were mostly located together: most changes occurred inside the reducer, and the event handlers went largely untouched. For me, this gives ",(0,s.mdx)("inlineCode",{parentName:"p"},"useReducer")," the edge over ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState"),"."),(0,s.mdx)("h3",{id:"usemachine-1"},"useMachine"),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 1"),": Add a new closing state, which after 500 milliseconds goes to the closed state."),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Refactor 2"),": Changed the targets of the ",(0,s.mdx)("inlineCode",{parentName:"p"},"TOGGLE")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"CLOSE")," actions to point at ",(0,s.mdx)("inlineCode",{parentName:"p"},"closing")," instead of ",(0,s.mdx)("inlineCode",{parentName:"p"},"closed"),"."),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-ts"},'export const machine = Machine({\n  id: "modalMachine",\n  initial: "closed",\n  states: {\n    closed: {\n      on: {\n        OPEN: {\n          target: "open",\n        },\n        TOGGLE: "open",\n      },\n    },\n    // Refactor 1\n    closing: {\n      after: {\n        500: "closed",\n      },\n    },\n    open: {\n      on: {\n        // Refactor 2\n        TOGGLE: "closing",\n        CLOSE: "closing",\n      },\n    },\n  },\n});\n\nconst [state, send] = useMachine(machine);\n\nconst open = () => {\n  send({ type: "OPEN" });\n};\n\nconst close = () => {\n  send({ type: "CLOSE" });\n};\n\nconst toggle = () => {\n  send({ type: "TOGGLE" });\n};\n')),(0,s.mdx)("blockquote",null,(0,s.mdx)("p",{parentName:"blockquote"},(0,s.mdx)("a",{parentName:"p",href:"https://xstate.js.org/viz/?gist=61bbac74d69894c9472571e44c98f765"},"See the changed machine here"),".")),(0,s.mdx)("p",null,"The difference here is stark. A minimal number of refactors, all within the state machine itself. The amount of lines has hardly changed. None of the event handlers changed. AND we have a working visualisation of the new implementation."),(0,s.mdx)("h2",{id:"conclusion"},"Conclusion"),(0,s.mdx)("p",null,"Before the requirements changed, ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," was the champion. It\u2019s faster, easier to implement, and fairly clear. ",(0,s.mdx)("inlineCode",{parentName:"p"},"useReducer")," and ",(0,s.mdx)("inlineCode",{parentName:"p"},"useMachine")," were too verbose, but ",(0,s.mdx)("inlineCode",{parentName:"p"},"useMachine")," took the edge by being easier to visualise."),(0,s.mdx)("p",null,"But after the requirements changed, ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState")," hit the floor. It quickly became the ",(0,s.mdx)("em",{parentName:"p"},"worst")," implementation. It was the hardest to refactor, and its refactors were in the most diverse places. ",(0,s.mdx)("inlineCode",{parentName:"p"},"useReducer")," was equally hard to refactor, with the same set of changes. ",(0,s.mdx)("inlineCode",{parentName:"p"},"useMachine")," emerged as the champion, with a minimal diff required to build in new, complex functionality."),(0,s.mdx)("p",null,"So if you\u2019re looking to build a modal fast, use ",(0,s.mdx)("inlineCode",{parentName:"p"},"useState"),". If you want to build it right, use ",(0,s.mdx)("inlineCode",{parentName:"p"},"useMachine"),"."),(0,s.mdx)("p",null,"I\u2019m excited to work on this set of articles - I\u2019m looking forward to tackling the toughest state models out there. What would you like to see covered in the next one? Some ideas:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"Data fetching"),(0,s.mdx)("li",{parentName:"ul"},"Form state"),(0,s.mdx)("li",{parentName:"ul"},"Multi-step sequences (checkout flows, signup flows)")),(0,s.mdx)("p",null,"Let me know in the comments below, and follow me for the next article!"))}m.isMDXComponent=!0}}]);