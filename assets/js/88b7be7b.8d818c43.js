"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[97474],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>m,mdx:()=>f,useMDXComponents:()=>p,withMDXComponents:()=>l});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),l=function(e){return function(n){var t=p(n.components);return a.createElement(e,o({},n,{components:t}))}},p=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),l=p(t),m=r,h=l["".concat(i,".").concat(m)]||l[m]||u[m]||o;return t?a.createElement(h,s(s({ref:n},d),{},{components:t})):a.createElement(h,s({ref:n},d))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},38230:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(87462),r=(t(67294),t(3905));const o={title:"Node",description:"Patterns for long-running processes and async functions when running machines in Node."},i="Node",s={unversionedId:"xstate/running-machines/node",id:"version-4/xstate/running-machines/node",title:"Node",description:"Patterns for long-running processes and async functions when running machines in Node.",source:"@site/versioned_docs/version-4/xstate/running-machines/node.mdx",sourceDirName:"xstate/running-machines",slug:"/xstate/running-machines/node",permalink:"/statelyai-docs/docs/xstate-v4/xstate/running-machines/node",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/versioned_docs/version-4/xstate/running-machines/node.mdx",tags:[],version:"4",frontMatter:{title:"Node",description:"Patterns for long-running processes and async functions when running machines in Node."},sidebar:"tutorialSidebar",previous:{title:"XState in React",permalink:"/statelyai-docs/docs/xstate-v4/xstate/running-machines/react"},next:{title:"Deep dive: states",permalink:"/statelyai-docs/docs/xstate-v4/category/xstate-states"}},c={},d=[{value:"Long-running processes",id:"long-running-processes",level:2},{value:"Async functions",id:"async-functions",level:2}],l={toc:d};function p(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"node"},"Node"),(0,r.mdx)("p",null,"When running machines in Node, a few common patterns emerge."),(0,r.mdx)("h2",{id:"long-running-processes"},"Long-running processes"),(0,r.mdx)("p",null,"The first pattern is running XState to coordinate a long-running process, for instance, a file watcher in a CLI (Command Line Interface):"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},'import { interpret, createMachine } from "xstate";\nimport { watch } from "chokidar";\n\nconst machine = createMachine({\n  initial: "waitingForChokidarToBeReady",\n  states: {\n    waitingForChokidarToBeReady: {\n      on: {\n        CHOKIDAR_READY: {\n          target: "chokidarReady",\n        },\n      },\n    },\n    chokidarReady: {\n      entry: () => {\n        console.log("Chokidar Ready!");\n      },\n    },\n  },\n});\n\nconst main = () => {\n  const actor = interpret(machine).start();\n\n  watch("./**").on("ready", () => {\n    actor.send("CHOKIDAR_READY");\n  });\n};\n\nmain();\n')),(0,r.mdx)("p",null,"In the script above, we run our main actor by calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"interpret().start()")," on the ",(0,r.mdx)("inlineCode",{parentName:"p"},"machine"),". We use ",(0,r.mdx)("a",{parentName:"p",href:"https://www.npmjs.com/package/chokidar"},(0,r.mdx)("inlineCode",{parentName:"a"},"chokidar")),", a file watcher, to watch over a set of files and then report that the watcher is ready to the actor. The actor then logs a message to the console."),(0,r.mdx)("p",null,"XState is extremely powerful at managing long-running processes like this, where multiple event sources need to be coordinated. You could even extend the example above to handle a process, which ",(0,r.mdx)("a",{parentName:"p",href:"https://gatsbyjs.com"},"Gatsby")," does for its build processing."),(0,r.mdx)("h2",{id:"async-functions"},"Async functions"),(0,r.mdx)("p",null,"Lots of backend code relies on short-running processes, such as backend functions, especially in serverless contexts where code needs to boot up and shut down as fast as possible."),(0,r.mdx)("p",null,"Much of this type of code relies on ",(0,r.mdx)("inlineCode",{parentName:"p"},"async")," functions:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const myFunc = async () => {};\n")),(0,r.mdx)("p",null,"The best pattern to use for async functions is ",(0,r.mdx)("inlineCode",{parentName:"p"},"waitFor"),", which allows you to ",(0,r.mdx)("inlineCode",{parentName:"p"},"await")," a state machine being in a particular state."),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},'import { interpret, createMachine } from "xstate";\nimport { waitFor } from "xstate/lib/waitFor";\n\nconst machine = createMachine({\n  initial: "pending",\n  states: {\n    pending: {\n      after: {\n        3000: {\n          target: "done",\n        },\n      },\n    },\n    done: {},\n  },\n});\n\nconst myFunc = async () => {\n  const actor = interpret(machine).start();\n\n  const doneState = await waitFor(actor, (state) =>\n    state.matches("done"),\n  );\n\n  console.log(doneState.value); // \'done\'\n};\n')),(0,r.mdx)("p",null,"In the example above, the machine waits for three seconds before moving on to its ",(0,r.mdx)("inlineCode",{parentName:"p"},"done")," state, at which point the ",(0,r.mdx)("inlineCode",{parentName:"p"},"await")," will resolve, and the program will move on."),(0,r.mdx)("p",null,"By default, ",(0,r.mdx)("inlineCode",{parentName:"p"},"waitFor")," will time out after 10 seconds if the desired state is not reached. You can customize this timeout by passing ",(0,r.mdx)("inlineCode",{parentName:"p"},"timeout")," in the options:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},'import { interpret, createMachine } from "xstate";\nimport { waitFor } from "xstate/lib/waitFor";\n\nconst machine = createMachine({\n  initial: "pending",\n  states: {\n    pending: {\n      after: {\n        3000: {\n          target: "done",\n        },\n      },\n    },\n    done: {},\n  },\n});\n\nconst myFunc = async () => {\n  const actor = interpret(machine).start();\n\n  const doneState = await waitFor(\n    actor,\n    (state) => state.matches("done"),\n    // highlight-start\n    {\n      // 20 seconds in ms\n      timeout: 20_000,\n    },\n    // highlight-end\n  );\n};\n')),(0,r.mdx)("p",null,(0,r.mdx)("inlineCode",{parentName:"p"},"waitFor")," will also throw an error if the actor reaches a final state ",(0,r.mdx)("em",{parentName:"p"},"before")," satisfying the condition. ",(0,r.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/xstate-v4/xstate/states/final-states"},"Read more about final states"),"."))}p.isMDXComponent=!0}}]);