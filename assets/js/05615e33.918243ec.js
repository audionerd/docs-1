"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[87722],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>l,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>m,withMDXComponents:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},s.apply(this,arguments)}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){return function(t){var n=m(t.components);return a.createElement(e,s({},t,{components:n}))}},m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),c=m(n),p=i,f=c["".concat(o,".").concat(p)]||c[p]||h[p]||s;return n?a.createElement(f,r(r({ref:t},l),{},{components:n})):a.createElement(f,r({ref:t},l))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,o=new Array(s);o[0]=f;var r={};for(var d in t)hasOwnProperty.call(t,d)&&(r[d]=t[d]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},76940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=n(87462),i=(n(67294),n(3905));const s={title:"Finite states"},o=void 0,r={unversionedId:"finite-states",id:"finite-states",title:"Finite states",description:'A finite state is one of the possible states that a state machine can be in at any given time. It\'s called "finite" because there should be a limited number of possible states that the machine can be in. Finite states define how a machine "behaves" when in a state; e.g. a status or a mode. They represent how a machine "behaves" when in a state; e.g. a status or a mode; a machine can behave differently depending what state it is in.',source:"@site/docs/finite-states.mdx",sourceDirName:".",slug:"/finite-states",permalink:"/statelyai-docs/docs/finite-states",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/finite-states.mdx",tags:[],version:"current",frontMatter:{title:"Finite states"},sidebar:"docs",previous:{title:"Guards",permalink:"/statelyai-docs/docs/guards"},next:{title:"Parent states",permalink:"/statelyai-docs/docs/parent-states"}},d={},l=[{value:"Finite states in Stately Studio",id:"finite-states-in-stately-studio",level:2},{value:"Initial state",id:"initial-state",level:2},{value:"State nodes",id:"state-nodes",level:2},{value:"Tags",id:"tags",level:2},{value:"Meta",id:"meta",level:2},{value:"Transitions",id:"transitions",level:2},{value:"Targets",id:"targets",level:2},{value:"Identifying state nodes",id:"identifying-state-nodes",level:2},{value:"Other state types",id:"other-state-types",level:2},{value:"Modeling states",id:"modeling-states",level:2},{value:"TypeScript",id:"typescript",level:2},{value:"Cheatsheet",id:"cheatsheet",level:2}],c={toc:l};function m(e){let{components:t,...n}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,'A finite state is one of the possible states that a state machine can be in at any given time. It\'s called "finite" because there should be a limited number of possible states that the machine can be in. Finite states define how a machine "behaves" when in a state; e.g. a status or a mode. They represent how a machine "behaves" when in a state; e.g. a status or a mode; a machine can behave differently depending what state it is in.'),(0,i.mdx)("p",null,'For example in a feedback form, you can be in a state where you are filling out the form, or a state where the form is being submitted. You cannot be filling out the form and submitting it at the same time; this is an "impossible state".'),(0,i.mdx)("p",null,"State machines always start at an ",(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/initial-states"},"initial state"),", and may end at a ",(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/final-states"},"final state"),". The state machine is always in a finite state."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  id: 'feedback',\n\n  // Initial state\n  initial: 'prompt',\n\n  // Finite states\n  states: {\n    prompt: {\n      /* ... */\n    },\n    form: {\n      /* ... */\n    },\n    thanks: {\n      /* ... */\n    },\n    closed: {\n      /* ... */\n    },\n  },\n});\n")),(0,i.mdx)("p",null,"You can combine finite states with ",(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/context"},"context"),", which make up the overall state of a machine:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  id: 'feedback',\n  context: {\n    name: '',\n    email: '',\n    feedback: '',\n  },\n\n  initial: 'prompt',\n  states: {\n    prompt: {\n      /* ... */\n    },\n  },\n});\n\nconst feedbackActor = createActor(feedbackMachine).start();\n\n// Finite state\nconsole.log(feedbackActor.getSnapshot().value);\n// logs 'prompt'\n\n// Context (\"extended state\")\nconsole.log(feedbackActor.getSnapshot().context);\n// logs { name: '', email: '', feedback: '' }\n")),(0,i.mdx)("p",null,"Coming soon\u2026 ",(0,i.mdx)("inlineCode",{parentName:"p"},".getSnapshot()")," and show ",(0,i.mdx)("inlineCode",{parentName:"p"},".value")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},".context")),(0,i.mdx)("h2",{id:"finite-states-in-stately-studio"},"Finite states in Stately Studio"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Coming soon\u2026 set initial state"),(0,i.mdx)("li",{parentName:"ul"},"Coming soon\u2026 change initial states"),(0,i.mdx)("li",{parentName:"ul"},"Coming soon\u2026 unreachable states"),(0,i.mdx)("li",{parentName:"ul"},"Coming soon\u2026 states with same key")),(0,i.mdx)("p",null,"Coming soon\u2026 image"),(0,i.mdx)("hr",null),(0,i.mdx)("h2",{id:"initial-state"},"Initial state"),(0,i.mdx)("p",null,"The initial state is the state that the machine starts in. It is defined by the ",(0,i.mdx)("inlineCode",{parentName:"p"},"initial")," property on the machine config:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  id: 'feedback',\n\n  // highlight-start\n  // Initial state\n  initial: 'prompt',\n  // highlight-end\n\n  // Finite states\n  states: {\n    // highlight-next-line\n    prompt: {\n      /* ... */\n    },\n    // ...\n  },\n});\n")),(0,i.mdx)("p",null,(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/initial-states"},"Read more about initial states"),"."),(0,i.mdx)("h2",{id:"state-nodes"},"State nodes"),(0,i.mdx)("p",null,"In XState, a ",(0,i.mdx)("strong",{parentName:"p"},"state node"),' is a finite state "nodes" that comprise the entire statechart tree. State nodes are defined on the ',(0,i.mdx)("inlineCode",{parentName:"p"},"states")," property of other state nodes, including the root machine config (which itself is a state node):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"// The machine is the root state node\nconst feedbackMachine = createMachine({\n  id: 'feedback',\n  initial: 'prompt',\n\n  // State nodes\n  states: {\n    // State node\n    prompt: {\n      /* ... */\n    },\n    // State node\n    form: {\n      /* ... */\n    },\n    // State node\n    thanks: {\n      /* ... */\n    },\n    // State node\n    closed: {\n      /* ... */\n    },\n  },\n});\n")),(0,i.mdx)("h2",{id:"tags"},"Tags"),(0,i.mdx)("p",null,"State nodes can have ",(0,i.mdx)("strong",{parentName:"p"},"tags"),', which are string terms that help group or categorize the state node. For example, you can signify which state nodes represent states in which data is being loaded by using a "loading" tag, and determine if a state contains those tagged state nodes with ',(0,i.mdx)("inlineCode",{parentName:"p"},"state.hasTag(tag)"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  id: 'feedback',\n  initial: 'prompt',\n  states: {\n    prompt: {\n      tags: ['visible'],\n      // ...\n    },\n    form: {\n      tags: ['visible'],\n      // ...\n    },\n    thanks: {\n      tags: ['visible', 'confetti'],\n      // ...\n    },\n    closed: {\n      tags: ['hidden'],\n    },\n  },\n});\n\nconst feedbackActor = createActor(feedbackMachine).start();\n\nconsole.log(feedbackActor..getSnapshot().hasTag('visible'));\n// logs true\n")),(0,i.mdx)("p",null,"Read more about ",(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/tags"},"tags"),"."),(0,i.mdx)("h2",{id:"meta"},"Meta"),(0,i.mdx)("p",null,"Meta data is static data that describes relevant properties of a state node. You can specify meta data on the ",(0,i.mdx)("inlineCode",{parentName:"p"},".meta")," property of any state node. This can be useful for displaying information about a state node in a UI, or for generating documentation."),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"state.meta")," property collects the ",(0,i.mdx)("inlineCode",{parentName:"p"},".meta")," data from all active state nodes and places them in an object with the state node's ID as the key and the ",(0,i.mdx)("inlineCode",{parentName:"p"},".meta")," data as the value:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  id: 'feedback',\n  initial: 'prompt',\n  meta: {\n    title: 'Feedback',\n  },\n  states: {\n    prompt: {\n      meta: {\n        content: 'How was your experience?',\n      },\n    },\n    form: {\n      meta: {\n        content: 'Please fill out the form below.',\n      },\n    },\n    thanks: {\n      meta: {\n        content: 'Thank you for your feedback!',\n      },\n    },\n    closed: {},\n  },\n});\n\nconst feedbackActor = createActor(feedbackMachine).start();\n\nconsole.log(feedbackActor.getSnapshot().meta);\n// logs the object:\n// {\n//   feedback: {\n//     title: 'Feedback',\n//   },\n//   'feedback.prompt': {\n//     content: 'How was your experience?',\n//   }\n// }\n")),(0,i.mdx)("h2",{id:"transitions"},"Transitions"),(0,i.mdx)("p",null,"Transitions are how you move from one finite state to another. They are defined by the ",(0,i.mdx)("inlineCode",{parentName:"p"},"on")," property on a state node:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      on: {\n        'feedback.good': {\n          target: 'thanks',\n        },\n      },\n    },\n    thanks: {\n      /* ... */\n    },\n    // ...\n  },\n});\n\nconst feedbackActor = createActor(feedbackMachine).start();\n\nconsole.log(feedbackActor.getSnapshot().value);\n// logs 'prompt'\n\nfeedbackActor.send({ type: 'feedback.good' });\n\nconsole.log(feedbackActor.getSnapshot().value);\n// logs 'thanks'\n")),(0,i.mdx)("p",null,"Read more about ",(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/transitions"},"events and transitions"),"."),(0,i.mdx)("h2",{id:"targets"},"Targets"),(0,i.mdx)("p",null,"A transition's ",(0,i.mdx)("inlineCode",{parentName:"p"},"target")," property defines where the machine should go when the transition is taken. Normally, it targets a sibling state node:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      on: {\n        'feedback.good': {\n          // highlight-start\n          // Targets the sibling `thanks` state node\n          target: 'thanks',\n          // highlight-end\n        },\n      },\n    },\n    thanks: {\n      /* ... */\n    },\n    // ...\n  },\n});\n")),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"target")," can also target a descendant of a sibling state node:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      on: {\n        'feedback.good': {\n          // highlight-start\n          // Targets the sibling `thanks.happy` state node\n          target: 'thanks.happy',\n          // highlight-end\n        },\n      },\n    },\n    thanks: {\n      initial: 'normal',\n      states: {\n        normal: {},\n        // highlight-next-line\n        happy: {},\n      },\n    },\n    // ...\n  },\n});\n")),(0,i.mdx)("p",null,"When the target state node is a descendant of the source state node, the source state node key can be omitted:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  // ...\n  states: {\n    closed: {\n      initial: 'normal',\n      states: {\n        normal: {},\n        keypress: {},\n      },\n    },\n  },\n  on: {\n    'feedback.close': {\n      // highlight-start\n      // Targets the descendant `closed` state node\n      target: '.closed',\n      // highlight-end\n    },\n    'key.escape': {\n      // highlight-start\n      // Targets the descendant `closed.keypress` state node\n      target: '.closed.keypress',\n      // highlight-end\n    },\n  },\n});\n")),(0,i.mdx)("p",null,"When the state node doesn't change; i.e., the source and target state nodes are the same, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"target")," property can be omitted:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  // ...\n  states: {\n    form: {\n      on: {\n        'feedback.update': {\n          // highlight-start\n          // No target defined \u2013 stay on the `form` state node\n          // Equivalent to `target: '.form'` or `target: undefined`\n          // highlight-end\n          actions: 'updateForm',\n        },\n      },\n    },\n  },\n});\n")),(0,i.mdx)("p",null,"State nodes can also be targeted by their ",(0,i.mdx)("inlineCode",{parentName:"p"},"id")," by prefixing the ",(0,i.mdx)("inlineCode",{parentName:"p"},"target")," with a ",(0,i.mdx)("inlineCode",{parentName:"p"},"#")," followed by the state node's ",(0,i.mdx)("inlineCode",{parentName:"p"},"id"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    // highlight-start\n    closed: {\n      id: 'finished',\n    },\n    // highlight-end\n    // ...\n  },\n  on: {\n    'feedback.close': {\n      // highlight-next-line\n      target: '#finished',\n    },\n  },\n});\n")),(0,i.mdx)("h2",{id:"identifying-state-nodes"},"Identifying state nodes"),(0,i.mdx)("p",null,"States can be identified with a unique ID: ",(0,i.mdx)("inlineCode",{parentName:"p"},"id: 'myState'"),". This is useful for targeting a state from any other state, even if they have different parent states:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createActor } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    // ...\n    closed: {\n      // highlight-next-line\n      id: 'finished',\n      type: 'final',\n    },\n    // ...\n  },\n  on: {\n    'feedback.close': {\n      // highlight-start\n      // Target the `.closed` state by its ID\n      target: '#finished',\n      // highlight-end\n    },\n  },\n});\n")),(0,i.mdx)("p",null,"State IDs do not affect the ",(0,i.mdx)("inlineCode",{parentName:"p"},"state.value"),". In the above example, the ",(0,i.mdx)("inlineCode",{parentName:"p"},"state.value")," would still be ",(0,i.mdx)("inlineCode",{parentName:"p"},"closed")," even though the state node is identified as ",(0,i.mdx)("inlineCode",{parentName:"p"},"#finished"),"."),(0,i.mdx)("h2",{id:"other-state-types"},"Other state types"),(0,i.mdx)("p",null,"In statecharts, there are other types of states:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/statelyai-docs/docs/parent-states"},"Parent states (also known as compound states)")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/statelyai-docs/docs/parallel-states"},"Parallel states")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/statelyai-docs/docs/history-states"},"History states")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/statelyai-docs/docs/final-states"},"Final states"))),(0,i.mdx)("h2",{id:"modeling-states"},"Modeling states"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"Start simple and shallow. Don't create multiple finite states until it becomes apparent that the behavior of your logic differs depending on some finite state it can be in."),(0,i.mdx)("li",{parentName:"ul"},"Can model choice pseudostates")),(0,i.mdx)("h2",{id:"typescript"},"TypeScript"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Coming soon")),(0,i.mdx)("h2",{id:"cheatsheet"},"Cheatsheet"),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Coming soon")))}m.isMDXComponent=!0}}]);