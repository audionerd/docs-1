"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[89329],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>m,mdx:()=>g,useMDXComponents:()=>u,withMDXComponents:()=>c});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=a.createContext({}),c=function(e){return function(t){var n=u(t.components);return a.createElement(e,i({},t,{components:n}))}},u=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),c=u(n),m=o,p=c["".concat(s,".").concat(m)]||c[m]||h[m]||i;return n?a.createElement(p,l(l({ref:t},d),{},{components:n})):a.createElement(p,l({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=p;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var d=2;d<i;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},73683:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(87462),o=(n(67294),n(3905));const i={title:"No, disabling a button is not app logic.",description:"Disabling a button is not logic. Rather, it is a sign that logic is fragile and bug-prone. Let\u2019s explore this with a simple example: fetching data in a React component.",tags:["data fetching","state machine","statechart","state","business logic"],authors:["david"],image:"/blog/2019-11-13-no-disabling-a-button-is-not-app-logic.png",slug:"2019-11-13-no-disabling-a-button-is-not-app-logic",date:new Date("2019-11-13T00:00:00.000Z")},s=void 0,l={permalink:"/blog/2019-11-13-no-disabling-a-button-is-not-app-logic",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2019-11-13-no-disabling-a-button-is-not-app-logic/index.mdx",source:"@site/blog/2019-11-13-no-disabling-a-button-is-not-app-logic/index.mdx",title:"No, disabling a button is not app logic.",description:"Disabling a button is not logic. Rather, it is a sign that logic is fragile and bug-prone. Let\u2019s explore this with a simple example: fetching data in a React component.",date:"2019-11-13T00:00:00.000Z",formattedDate:"November 13, 2019",tags:[{label:"data fetching",permalink:"/blog/tags/data-fetching"},{label:"state machine",permalink:"/blog/tags/state-machine"},{label:"statechart",permalink:"/blog/tags/statechart"},{label:"state",permalink:"/blog/tags/state"},{label:"business logic",permalink:"/blog/tags/business-logic"}],readingTime:15.28,hasTruncateMarker:!0,authors:[{name:"David Khourshid",title:"Stately Team",url:"https://github.com/davidkpiano",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/david.png",key:"david"}],frontMatter:{title:"No, disabling a button is not app logic.",description:"Disabling a button is not logic. Rather, it is a sign that logic is fragile and bug-prone. Let\u2019s explore this with a simple example: fetching data in a React component.",tags:["data fetching","state machine","statechart","state","business logic"],authors:["david"],image:"/blog/2019-11-13-no-disabling-a-button-is-not-app-logic.png",slug:"2019-11-13-no-disabling-a-button-is-not-app-logic",date:"2019-11-13T00:00:00.000Z"},prevItem:{title:"XState: version 4.7 and the future",permalink:"/blog/2019-12-09-xstate-version-47-and-the-future"}},r={authorsImageUrls:[void 0]},d=[{value:"Trying to make <code>fetch()</code> happen",id:"trying-to-make-fetch-happen",level:2},{value:"What can possibly go wrong?",id:"what-can-possibly-go-wrong",level:2},{value:"DRYing up the splashes of logic",id:"drying-up-the-splashes-of-logic",level:2},{value:"Adding features and complexity",id:"adding-features-and-complexity",level:2},{value:"Reducing complexity effectively",id:"reducing-complexity-effectively",level:2},{value:"The fabled &quot;disabled&quot; attribute",id:"the-fabled-disabled-attribute",level:2},{value:"The final result",id:"the-final-result",level:2},{value:"Pushing effects to the side",id:"pushing-effects-to-the-side",level:2},{value:"Using a state machine",id:"using-a-state-machine",level:2},{value:"Final points",id:"final-points",level:2}],c={toc:d};function u(e){let{components:t,...n}=e;return(0,o.mdx)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("head",null,(0,o.mdx)("link",{rel:"canonical",href:"https://dev.to/davidkpiano/no-disabling-a-button-is-not-app-logic-598i"})),(0,o.mdx)("p",null,"I\u2019m going to start this post with an excerpt from the book \u201cConstructing the User Interface with Statecharts\u201d, written by Ian Horrocks in 1999:"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"User interface development tools are very powerful. They can be used to construct large and complex user interfaces, with only a relatively small amount of code written by an application developer. And yet, despite the power of such tools and the relatively small amount of code that is written, user interface software often has the following characteristics:"),(0,o.mdx)("ul",{parentName:"blockquote"},(0,o.mdx)("li",{parentName:"ul"},"the code can be difficult to understand and review thoroughly:"),(0,o.mdx)("li",{parentName:"ul"},"the code can be difficult to test in a systematic and thorough way;"),(0,o.mdx)("li",{parentName:"ul"},"the code can contain bugs even after extensive testing and bug fixing;"),(0,o.mdx)("li",{parentName:"ul"},"the code can be difficult to enhance without introducing unwanted side-effects;"),(0,o.mdx)("li",{parentName:"ul"},"the quality of the code tends to deteriorate as enhancements are made to it.")),(0,o.mdx)("p",{parentName:"blockquote"},"Despite the obvious problems associated with user interface development, ",(0,o.mdx)("strong",{parentName:"p"},"little effort has been made to improve the situation"),". Any practitioner who has worked on large user interface projects will be familiar with many of the above characteristics, which are ",(0,o.mdx)("strong",{parentName:"p"},"symptomatic of the way in which the software is constructed"),".")),(0,o.mdx)("p",null,"In case you didn\u2019t do the math, this was written ",(0,o.mdx)("em",{parentName:"p"},"over 20 years ago")," and yet it echoes the same sentiments that many developers feel today about the state of app development. Why is that?"),(0,o.mdx)("p",null,"We\u2019ll explore this with a simple example: fetching data in a React component. Keep in mind, the ideas presented in this article are not library-specific, nor framework-specific\u2026 in fact, they\u2019re not even language specific!"),(0,o.mdx)("h2",{id:"trying-to-make-fetch-happen"},"Trying to make ",(0,o.mdx)("inlineCode",{parentName:"h2"},"fetch()")," happen"),(0,o.mdx)("p",null,"Suppose we have a ",(0,o.mdx)("inlineCode",{parentName:"p"},"DogFetcher")," component that has a button that you can click to fetch a random dog. When the button is clicked, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"GET")," request is made to the ",(0,o.mdx)("a",{parentName:"p",href:"https://dog.ceo/dog-api/"},"Dog API"),", and when the dog is received, we show it off in an ",(0,o.mdx)("inlineCode",{parentName:"p"},"<img />")," tag."),(0,o.mdx)("p",null,"A typical implementation with ",(0,o.mdx)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"React Hooks")," might look like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function DogFetcher() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [dog, setDog] = useState(null);\n\n  return (\n    <div>\n      <figure className="dog">{dog && <img src={dog} alt="doggo" />}</figure>\n\n      <button\n        onClick={() => {\n          setIsLoading(true);\n          fetch(`https://dog.ceo/api/breeds/image/random`)\n            .then((data) => data.json())\n            .then((response) => {\n              setDog(response.message);\n              setIsLoading(false);\n            });\n        }}\n      >\n        {isLoading ? "Fetching..." : "Fetch dog!"}\n      </button>\n    </div>\n  );\n}\n')),(0,o.mdx)("p",null,"This works, but there\u2019s one immediate problem: clicking the button more than once (while a dog is loading) will display one dog briefly, and then replace that dog with another dog. That\u2019s not very considerate to the first dog."),(0,o.mdx)("p",null,"The typical solution to this is to add a ",(0,o.mdx)("inlineCode",{parentName:"p"},"disabled={isLoading}")," attribute to the button:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function DogFetcher() {\n  // ...\n\n  <button\n    onClick={() => {\n      // ... excessive amount of ad-hoc logic\n    }}\n    disabled={isLoading}\n  >\n    {isLoading ? "Fetching..." : "Fetch dog!"}\n  </button>;\n\n  // ...\n}\n')),(0,o.mdx)("p",null,"This also works; you\u2019re probably satisfied with this solution. Allow me to burst this bubble."),(0,o.mdx)("h2",{id:"what-can-possibly-go-wrong"},"What can possibly go wrong?"),(0,o.mdx)("p",null,"Currently, the logic reads like this:"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"When the button is clicked, fetch a new random dog, and set a flag to make sure that the button cannot be clicked again to fetch a dog while one is being fetched.")),(0,o.mdx)("p",null,"However, the logic you ",(0,o.mdx)("em",{parentName:"p"},"really")," want is this:"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"When a new dog is requested, fetch it and make sure that another dog can\u2019t be fetched at the same time.")),(0,o.mdx)("p",null,"See the difference? The desired logic is completely separate from the button being clicked; it doesn\u2019t matter ",(0,o.mdx)("em",{parentName:"p"},"how")," the request is made; it only matters what logic happens afterwards."),(0,o.mdx)("p",null,"Suppose that you want to add the feature that double-clicking the image loads a new dog. What would you have to do?"),(0,o.mdx)("p",null,"It\u2019s all too easy to forget to add the same \u201cguard\u201d logic on ",(0,o.mdx)("inlineCode",{parentName:"p"},"figure")," (after all, ",(0,o.mdx)("inlineCode",{parentName:"p"},"<figure disabled={isLoading}>")," won\u2019t work, go figure), but let\u2019s say you\u2019re an astute developer who remembers to add this logic:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"    function DogFetcher() {\n      // ...\n\n      <figure\n        onDoubleClick={() => {\n          if (isLoading) return;\n\n          // copy-paste the fetch logic from the button onClick handler\n        }}\n      >\n        {/* ... */}\n      </figure>\n\n      // ...\n\n      <button\n        onClick={() => {\n          // fetch logic\n        }}\n        disabled={isLoading}\n      >\n        {/* ... */}\n      </button>\n\n      // ...\n    }\n")),(0,o.mdx)("p",null,"In reality, you can think about this as any use-case where some sort of \u201ctrigger\u201d can happen from multiple locations, such as:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"a form being able to be submitted by pressing \u201cEnter\u201d in an input or clicking the \u201cSubmit\u201d button"),(0,o.mdx)("li",{parentName:"ul"},"an event being triggered by a user action ",(0,o.mdx)("em",{parentName:"li"},"or")," a timeout"),(0,o.mdx)("li",{parentName:"ul"},"any app logic that needs to be shared between different platforms with different event-handling implementations (think React Native)")),(0,o.mdx)("p",null,"But there\u2019s a code smell here. Our same fetch logic is implemented in more than one place, and understanding the app logic requires developers to jump around in multiple parts of the code base, finding all of the event handlers where there are tidbits of logic and connecting them together mentally."),(0,o.mdx)("h2",{id:"drying-up-the-splashes-of-logic"},"DRYing up the splashes of logic"),(0,o.mdx)("p",null,"Okay, so putting logic in our event handlers is probably not a good idea, but we can\u2019t exactly put our finger on the reason why yet. Let\u2019s move the fetch logic out into a function:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function DogFetcher() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [dog, setDog] = useState(null);\n\n  function fetchDog() {\n    if (isLoading) return;\n\n    setIsLoading(true);\n    fetch(`https://dog.ceo/api/breeds/image/random`)\n      .then((data) => data.json())\n      .then((response) => {\n        setDog(response.message);\n        setIsLoading(false);\n      });\n  }\n\n  return (\n    <div>\n      <figure className="dog" onDoubleClick={fetchDog}>\n        {dog && <img src={dog} alt="doggo" />}\n      </figure>\n\n      <button onClick={fetchDog}>\n        {isLoading ? "Fetching..." : "Fetch dog!"}\n      </button>\n    </div>\n  );\n}\n')),(0,o.mdx)("h2",{id:"adding-features-and-complexity"},"Adding features and complexity"),(0,o.mdx)("p",null,"Now let\u2019s see what happens when we want to add basic \u201cfeatures\u201d, such as:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"If fetching a dog fails, an error should be shown."),(0,o.mdx)("li",{parentName:"ul"},"Fetching a dog should be cancellable.")),(0,o.mdx)("p",null,"I hesitate to call these \u201cfeatures\u201d because these types of behaviors should be naturally enabled by the programming patterns used, but let\u2019s try to add them anyhow:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function DogFetcher() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [canceled, setCanceled] = useState(false);\n  const [dog, setDog] = useState(null);\n\n  function fetchDog() {\n    setCanceled(false);\n    setError(null);\n    setIsLoading(true);\n\n    fetchRandomDog()\n      .then((response) => {\n        // This should work... but it doesn\'t!\n        if (canceled) return;\n\n        setIsLoading(false);\n        setDog(response.message);\n      })\n      .catch((error) => {\n        setIsLoading(false);\n        setCanceled(false);\n        setError(error);\n      });\n  }\n\n  function cancel() {\n    setIsLoading(false);\n    setCanceled(true);\n  }\n\n  return (\n    <div>\n      {error && <span style={{ color: "red" }}>{error}</span>}\n      <figure className="dog" onDoubleClick={fetchDog}>\n        {dog && <img src={dog} alt="doggo" />}\n      </figure>\n\n      <button onClick={fetchDog}>\n        {isLoading ? "Fetching..." : "Fetch dog!"}\n      </button>\n      <button onClick={cancel}>Cancel</button>\n    </div>\n  );\n}\n')),(0,o.mdx)("p",null,"This ",(0,o.mdx)("em",{parentName:"p"},"looks")," like it should work -- all of our Boolean flags are being set to the correct values when things happen. However, ",(0,o.mdx)("strong",{parentName:"p"},"it does not work")," because of a hard-to-catch bug: ",(0,o.mdx)("em",{parentName:"p"},"stale callbacks"),". In this case, the ",(0,o.mdx)("inlineCode",{parentName:"p"},"canceled")," flag inside the ",(0,o.mdx)("inlineCode",{parentName:"p"},".then(...)")," callback will always be the previous value instead of the latest ",(0,o.mdx)("inlineCode",{parentName:"p"},"canceled")," value, so cancelling has no effect until the next time we try to fetch a dog, which isn\u2019t what we want."),(0,o.mdx)("p",null,"Hopefully you can see that even with these simple use-cases, our logic has quickly gone out-of-hand, and juggling Boolean flags has made the logic buggier and harder to understand."),(0,o.mdx)("h2",{id:"reducing-complexity-effectively"},"Reducing complexity effectively"),(0,o.mdx)("p",null,"Instead of haphazardly adding Boolean flags everywhere, let\u2019s clean this up with the ",(0,o.mdx)("inlineCode",{parentName:"p"},"useReducer")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"useEffect")," hooks. These hooks are useful because they express some concepts that lead to better logic organization:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"useReducer")," hook uses reducers, which return the next state given the current state and some event that just occurred."),(0,o.mdx)("li",{parentName:"ul"},"The ",(0,o.mdx)("inlineCode",{parentName:"li"},"useEffect")," hook synchronizes effects with state.")),(0,o.mdx)("p",null,"To help us organize the various app states, let\u2019s define a few and put them under a ",(0,o.mdx)("inlineCode",{parentName:"p"},"status")," property:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"An ",(0,o.mdx)("inlineCode",{parentName:"li"},'"idle"')," status means that nothing happened yet."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"loading"')," status means that the dog is currently being fetched."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"success"')," status means that the dog was successfully fetched."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"failure"')," status means that an error occurred while trying to fetch the dog.")),(0,o.mdx)("p",null,"Now let\u2019s define a few events that can happen in the app. Keep in mind: these events can happen from ",(0,o.mdx)("strong",{parentName:"p"},"anywhere"),", whether it\u2019s initiated by the user or somewhere else:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"FETCH"')," event indicates that fetching a dog should occur."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"RESOLVE"')," event with a ",(0,o.mdx)("inlineCode",{parentName:"li"},"data")," property indicates that a dog was successfully fetched."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"REJECT"')," event with an ",(0,o.mdx)("inlineCode",{parentName:"li"},"error")," property indicates that a dog was unable to be fetched for some reason."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("inlineCode",{parentName:"li"},'"CANCEL"')," event indicates that an in-progress fetch should be canceled.")),(0,o.mdx)("p",null,"Great! Now let\u2019s write our reducer:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function dogReducer(state, event) {\n  switch (event.type) {\n    case "FETCH":\n      return {\n        ...state,\n        status: "loading",\n      };\n    case "RESOLVE":\n      return {\n        ...state,\n        status: "success",\n        dog: event.data,\n      };\n    case "REJECT":\n      return {\n        ...state,\n        status: "failure",\n        error: event.error,\n      };\n    case "CANCEL":\n      return {\n        ...state,\n        status: "idle",\n      };\n    default:\n      return state;\n  }\n}\n\nconst initialState = {\n  status: "idle",\n  dog: null,\n  error: null,\n};\n')),(0,o.mdx)("p",null,"Here\u2019s the beautiful thing about this reducer. It is ",(0,o.mdx)("em",{parentName:"p"},"completely framework-agnostic")," - we can take this and use it in any framework, or no framework at all. And that also makes it much easier to test."),(0,o.mdx)("p",null,"But also, implementing this in a framework becomes ",(0,o.mdx)("em",{parentName:"p"},"reduced")," (pun intended) to ",(0,o.mdx)("em",{parentName:"p"},"just dispatching events"),". No more logic in event handlers:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function DogFetcher() {\n  const [state, dispatch] = useReducer(dogReducer, initialState);\n  const { error, dog, status } = state;\n\n  useEffect(() => {\n    // ... fetchDog?\n  }, [state.status]);\n\n  return (\n    <div>\n      {error && <span style={{ color: "red" }}>{error}</span>}\n      <figure className="dog" onDoubleClick={() => dispatch({ type: "FETCH" })}>\n        {dog && <img src={dog} alt="doggo" />}\n      </figure>\n\n      <button onClick={() => dispatch({ type: "FETCH" })}>\n        {status === "loading" ? "Fetching..." : "Fetch dog!"}\n      </button>\n      <button onClick={() => dispatch({ type: "CANCEL" })}>Cancel</button>\n    </div>\n  );\n}\n')),(0,o.mdx)("p",null,"However, the question remains: how do we execute the side-effect of actually fetching the dog? Well, since the ",(0,o.mdx)("inlineCode",{parentName:"p"},"useEffect")," hook is meant for synchronizing effects with state, we can synchronize the ",(0,o.mdx)("inlineCode",{parentName:"p"},"fetchDog()")," effect with ",(0,o.mdx)("inlineCode",{parentName:"p"},"status === 'loading'"),", since ",(0,o.mdx)("inlineCode",{parentName:"p"},"'loading'")," means that that side-effect is being executed anyway:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'// ...\nuseEffect(() => {\n  if (state.status === "loading") {\n    let canceled = false;\n\n    fetchRandomDog()\n      .then((data) => {\n        if (canceled) return;\n        dispatch({ type: "RESOLVE", data });\n      })\n      .catch((error) => {\n        if (canceled) return;\n        dispatch({ type: "REJECT", error });\n      });\n\n    return () => {\n      canceled = true;\n    };\n  }\n}, [state.status]);\n// ...\n')),(0,o.mdx)("h2",{id:"the-fabled-disabled-attribute"},'The fabled "disabled" attribute'),(0,o.mdx)("hr",null),(0,o.mdx)("p",null,"The logic above works great. We\u2019re able to:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Click the \u201cFetch dog\u201d button to fetch a dog"),(0,o.mdx)("li",{parentName:"ul"},"Display a random dog when fetched"),(0,o.mdx)("li",{parentName:"ul"},"Show an error if the dog is unable to be fetched"),(0,o.mdx)("li",{parentName:"ul"},"Cancel an in-flight fetch request by clicking the \u201cCancel\u201d button"),(0,o.mdx)("li",{parentName:"ul"},"Prevent more than one dog from being fetched at the same time")),(0,o.mdx)("p",null,"\u2026all without having to put any logic in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"<button disabled={...}>")," attribute. In fact, we completely forgot to do so anyway, and the logic still works!"),(0,o.mdx)("p",null,"This is how you know your logic is robust; when it works, regardless of the UI. Whether the \u201cFetch dog\u201d button is disabled or not, clicking it multiple times in a row won\u2019t exhibit any unexpected behavior."),(0,o.mdx)("p",null,"Also, because most of the logic is delegated to a ",(0,o.mdx)("inlineCode",{parentName:"p"},"dogReducer")," function defined ",(0,o.mdx)("em",{parentName:"p"},"outside")," of your component, it is:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"easy to make into a custom hook"),(0,o.mdx)("li",{parentName:"ul"},"easy to test"),(0,o.mdx)("li",{parentName:"ul"},"easy to reuse in other components"),(0,o.mdx)("li",{parentName:"ul"},"easy to reuse in other ",(0,o.mdx)("em",{parentName:"li"},"frameworks"))),(0,o.mdx)("h2",{id:"the-final-result"},"The final result"),(0,o.mdx)("p",null,"Change the ",(0,o.mdx)("inlineCode",{parentName:"p"},"<DogFetcher />")," version in the select dropdown to see each of the versions we've explored in this tutorial (even the buggy ones)."),(0,o.mdx)("h2",{id:"pushing-effects-to-the-side"},"Pushing effects to the side"),(0,o.mdx)("p",null,"There\u2019s one lingering thought, though\u2026 is ",(0,o.mdx)("inlineCode",{parentName:"p"},"useEffect()")," the ideal place to put a side effect, such as fetching?"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Maybe, maybe not.")),(0,o.mdx)("p",null,"Honestly, in most use-cases, it works, and it works fine. But it\u2019s difficult to test or separate that effect from your component code. And with the upcoming Suspense and Concurrent Mode features in React, the recommendation is to execute these side-effects when some action triggers them, rather than in ",(0,o.mdx)("inlineCode",{parentName:"p"},"useEffect()"),". This is because the official React advice is:"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"If you\u2019re working on a data fetching library, there\u2019s a crucial aspect of Render-as-You-Fetch you don\u2019t want to miss. ",(0,o.mdx)("strong",{parentName:"p"},"We kick off fetching before rendering.")),(0,o.mdx)("p",{parentName:"blockquote"},(0,o.mdx)("a",{parentName:"p",href:"https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early"},"https://reactjs.org/docs/concurrent-mode-suspense.html#start-fetching-early"))),(0,o.mdx)("p",null,"This is good advice. Fetching data should not be coupled with rendering. However, they also say this:"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"The answer to this is we want to start fetching in the event handlers instead.")),(0,o.mdx)("p",null,"This is misleading advice. Instead, here's what should happen:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"An event handler should ",(0,o.mdx)("strong",{parentName:"li"},"send a signal")," to \u201csomething\u201d that indicates that some action just happened (in the form of an event)"),(0,o.mdx)("li",{parentName:"ol"},"That \u201csomething\u201d should ",(0,o.mdx)("strong",{parentName:"li"},"orchestrate")," what happens next when it receives that event.")),(0,o.mdx)("p",null,"Two possible things can happen when an event is received by some orchestrator:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"State can be changed"),(0,o.mdx)("li",{parentName:"ul"},"Effects can be executed")),(0,o.mdx)("p",null,"All of this can happen outside of the component render cycle, because it doesn't necessarily concern the view. Unfortunately, React doesn't have a built-in way (yet?) to handle state management, side-effects, data fetching, caching etc. outside of the components (we all know Relay is not commonly used), so let's explore one way we can accomplish this completely outside of the component."),(0,o.mdx)("h2",{id:"using-a-state-machine"},"Using a state machine"),(0,o.mdx)("p",null,"In this case, we're going to use a state machine to manage and orchestrate state. If you're new to state machines, just know that they feel like your typical Redux reducers with a few more \"rules\". Those rules have some powerful advantages, and are also the mathematical basis for how literally every computer in existence today works. So they might be worth learning."),(0,o.mdx)("p",null,"I'm going to use ",(0,o.mdx)("a",{parentName:"p",href:"https://xstate.js.org/docs"},"XState")," and ",(0,o.mdx)("a",{parentName:"p",href:"https://xstate.js.org/docs/packages/xstate-react/"},(0,o.mdx)("inlineCode",{parentName:"a"},"@xstate/react"))," to create the machine:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'import { Machine, assign } from "xstate";\nimport { useMachine } from "@xstate/react";\n\n// ...\n\nconst dogFetcherMachine = Machine({\n  id: "dog fetcher",\n  initial: "idle",\n  context: {\n    dog: null,\n    error: null,\n  },\n  states: {\n    idle: {\n      on: { FETCH: "loading" },\n    },\n    loading: {\n      invoke: {\n        src: () => fetchRandomDog(),\n        onDone: {\n          target: "success",\n          actions: assign({ dog: (_, event) => event.data.message }),\n        },\n        onError: {\n          target: "failure",\n          actions: assign({ error: (_, event) => event.data }),\n        },\n      },\n      on: { CANCEL: "idle" },\n    },\n    success: {\n      on: { FETCH: "loading" },\n    },\n    failure: {\n      on: { FETCH: "loading" },\n    },\n  },\n});\n')),(0,o.mdx)("p",null,"Notice how the machine looks like our previous reducer, with a couple of differences:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"It looks like some sort of configuration object instead of a switch statement"),(0,o.mdx)("li",{parentName:"ul"},"We\u2019re matching on the ",(0,o.mdx)("em",{parentName:"li"},"state")," first, instead of the ",(0,o.mdx)("em",{parentName:"li"},"event")," first"),(0,o.mdx)("li",{parentName:"ul"},"We\u2019re invoking the ",(0,o.mdx)("inlineCode",{parentName:"li"},"fetchRandomDog()")," promise inside the machine! \ud83d\ude31")),(0,o.mdx)("p",null,"Don\u2019t worry; we\u2019re not actually executing any side-effects inside of this machine. In fact, ",(0,o.mdx)("inlineCode",{parentName:"p"},"dogFetcherMachine.transition(state, event)")," is a ",(0,o.mdx)("em",{parentName:"p"},"pure function")," that tells you the next state given the current state and event. Seems familiar, huh?"),(0,o.mdx)("p",null,"Furthermore, I can copy-paste this exact machine and ",(0,o.mdx)("a",{parentName:"p",href:"https://xstate.js.org/viz"},"visualize it in XState Viz"),":"),(0,o.mdx)("p",null,(0,o.mdx)("img",{parentName:"p",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--sSFyyRFI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://thepracticaldev.s3.amazonaws.com/i/hnsqk07cxbygbjo0h07j.png",alt:"Visualization of dog fetching machine"})),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"https://xstate.js.org/viz/?gist=414c0e4c40dab1dc80c9218f85605a24"},"View this viz on xstate.js.org/viz")),(0,o.mdx)("p",null,"So what does our component code look like now? Take a look:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'function DogFetcher() {\n  const [current, send] = useMachine(dogFetcherMachine);\n  const { error, dog } = current.context;\n\n  return (\n    <div>\n      {error && <span style={{ color: "red" }}>{error}</span>}\n      <figure className="dog" onDoubleClick={() => send("FETCH")}>\n        {dog && <img src={dog} alt="doggo" />}\n      </figure>\n\n      <button onClick={() => send("FETCH")}>\n        {current.matches("loading") && "Fetching..."}\n        {current.matches("success") && "Fetch another dog!"}\n        {current.matches("idle") && "Fetch dog"}\n        {current.matches("failure") && "Try again"}\n      </button>\n      <button onClick={() => send("CANCEL")}>Cancel</button>\n    </div>\n  );\n}\n')),(0,o.mdx)("p",null,"Here\u2019s the difference between using a state machine and a reducer:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"The hook signature for ",(0,o.mdx)("inlineCode",{parentName:"li"},"useMachine(...)")," looks almost the same as ",(0,o.mdx)("inlineCode",{parentName:"li"},"useReducer(...)")),(0,o.mdx)("li",{parentName:"ul"},"No fetching logic exists inside the component; it\u2019s all external!"),(0,o.mdx)("li",{parentName:"ul"},"There\u2019s a nice ",(0,o.mdx)("inlineCode",{parentName:"li"},"current.matches(...)")," function that lets us customize our button text"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"send(...)")," instead of ",(0,o.mdx)("inlineCode",{parentName:"li"},"dispatch(...)"),"... and it takes a plain string! (Or an object, up to you).")),(0,o.mdx)("p",null,"A state machine/statechart defines its transitions from the state because it answers the question: \u201cWhich events should be handled ",(0,o.mdx)("em",{parentName:"p"},"from this state?"),"\u201d The reason that having ",(0,o.mdx)("inlineCode",{parentName:"p"},"<button disabled={isLoading}>")," is fragile is because we admit that some \u201cFETCH\u201d event can cause an effect no matter which state we\u2019re in, so we have to clean up our ~mess~ faulty logic by preventing the user from clicking the button while loading."),(0,o.mdx)("p",null,"Instead, it\u2019s better to be proactive about your logic. Fetching should only happen when the app is not in some ",(0,o.mdx)("inlineCode",{parentName:"p"},'"loading"')," state, which is what is clearly defined in the state machine -- the ",(0,o.mdx)("inlineCode",{parentName:"p"},'"FETCH"')," event is not handled in the ",(0,o.mdx)("inlineCode",{parentName:"p"},'"loading"')," state, which means it has no effect. Perfect."),(0,o.mdx)("h2",{id:"final-points"},"Final points"),(0,o.mdx)("p",null,"Disabling a button is not logic. Rather, it is a sign that logic is fragile and bug-prone. In my opinion, disabling a button should only be a visual cue to the user that clicking the button ",(0,o.mdx)("em",{parentName:"p"},"will have no effect"),"."),(0,o.mdx)("p",null,"So when you\u2019re creating fetching logic (or any other kind of complex logic) in your applications, no matter the framework, ask yourself these questions:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},'What are the concrete, finite states this app/component can be in? E.g., "loading", "success", "idle", "failure", etc.'),(0,o.mdx)("li",{parentName:"ul"},"What are all the possible events that can occur, regardless of state? This includes events that don't come from the user (such as ",(0,o.mdx)("inlineCode",{parentName:"li"},'"RESOLVE"')," or ",(0,o.mdx)("inlineCode",{parentName:"li"},'"REJECT"')," events from promises)"),(0,o.mdx)("li",{parentName:"ul"},"Which of the finite states should handle these events?"),(0,o.mdx)("li",{parentName:"ul"},"How can I organize my app logic so that these events are handled properly in those states?")),(0,o.mdx)("p",null,"You do not need a state machine library (like XState) to do this. In fact, you might not even need ",(0,o.mdx)("inlineCode",{parentName:"p"},"useReducer")," when you\u2019re first adopting these principles. Even something as simple as having a state variable representing a finite state can already clean up your logic plenty:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"function DogFetcher() {\n  // 'idle' or 'loading' or 'success' or 'error'\n  const [status, setStatus] = useState(\"idle\");\n}\n")),(0,o.mdx)("p",null,"And just like that, you\u2019ve eliminated ",(0,o.mdx)("inlineCode",{parentName:"p"},"isLoading"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"isError"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"isSuccess"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"startedLoading"),", and whatever Boolean flags you were going to create. And if you really start to miss that ",(0,o.mdx)("inlineCode",{parentName:"p"},"isLoading")," flag (for whatever reason), you can still have it, but ONLY if it\u2019s derived from your organized, finite states. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"isLoading")," variable should NEVER be a primary source of state:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"function DogFetcher() {\n  // 'idle' or 'loading' or 'success' or 'error'\n  const [status, setStatus] = useState(\"idle\");\n\n  const isLoading = status === \"loading\";\n\n  return (\n    // ...\n    <button disabled={isLoading}>{/* ... */}</button>\n    // ...\n  );\n}\n")),(0,o.mdx)("p",null,"And we\u2019ve come full circle. Thanks for reading."))}u.isMDXComponent=!0}}]);