"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[73682],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>c,mdx:()=>u,useMDXComponents:()=>p,withMDXComponents:()=>m});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var d=a.createContext({}),m=function(e){return function(t){var n=p(t.components);return a.createElement(e,r({},t,{components:n}))}},p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},x=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,i=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(n),c=l,x=m["".concat(i,".").concat(c)]||m[c]||h[c]||r;return n?a.createElement(x,s(s({ref:t},d),{},{components:n})):a.createElement(x,s({ref:t},d))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=x;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:l,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}x.displayName="MDXCreateElement"},18672:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(87462),l=(n(67294),n(3905));const r={title:"@xstate/test"},i=void 0,s={unversionedId:"xstate-test",id:"xstate-test",title:"@xstate/test",description:"The @xstate/test package contains utilities for facilitating model-based testing for any software.",source:"@site/docs/xstate-test.mdx",sourceDirName:".",slug:"/xstate-test",permalink:"/docs/xstate-test",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/xstate-test.mdx",tags:[],version:"current",frontMatter:{title:"@xstate/test"},sidebar:"docs",previous:{title:"@xstate/graph",permalink:"/docs/xstate-graph"},next:{title:"@xstate/immer",permalink:"/docs/xstate-immer"}},o={},d=[{value:"Quick start",id:"quick-start",level:2},{value:"API",id:"api",level:2},{value:"<code>createModel(machine, options?)</code>",id:"createmodelmachine-options",level:3},{value:"Returns",id:"returns",level:4},{value:"Methods",id:"methods",level:3},{value:"<code>model.withEvents(eventsMap)</code>",id:"modelwitheventseventsmap",level:4},{value:"<code>testModel.getShortestPathPlans(options?)</code>",id:"testmodelgetshortestpathplansoptions",level:3},{value:"Options",id:"options",level:4},{value:"<code>testModel.getSimplePathPlans(options?)</code>",id:"testmodelgetsimplepathplansoptions",level:3},{value:"Options",id:"options-1",level:4},{value:"<code>testModel.getPlanFromEvents(events, options)</code>",id:"testmodelgetplanfromeventsevents-options",level:3},{value:"<code>testModel.testCoverage(options?)</code>",id:"testmodeltestcoverageoptions",level:3},{value:"Options",id:"options-2",level:4},{value:"<code>testPlan.description</code>",id:"testplandescription",level:3},{value:"<code>testPlan.paths</code>",id:"testplanpaths",level:3},{value:"<code>testPath.description</code>",id:"testpathdescription",level:3},{value:"<code>testPath.test(testContext)</code>",id:"testpathtesttestcontext",level:3}],m={toc:d};function p(e){let{components:t,...n}=e;return(0,l.mdx)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.mdx)("p",null,"The ",(0,l.mdx)("a",{parentName:"p",href:"https://github.com/statelyai/xstate/tree/main/packages/xstate-test"},"@xstate/test package")," contains utilities for facilitating ",(0,l.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Model-based_testing"},"model-based testing")," for any software."),(0,l.mdx)("p",null,(0,l.mdx)("strong",{parentName:"p"},"Watch the talk"),": ",(0,l.mdx)("a",{parentName:"p",href:"https://slides.com/davidkhourshid/mbt"},"Write Fewer Tests! From Automation to Autogeneration")," at React Rally 2019 (",(0,l.mdx)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=tpNmPKjPSFQ"},(0,l.mdx)("span",{parentName:"a",role:"img","aria-label":"movie camera"},"\ud83c\udfa5")," Video"),")"),(0,l.mdx)("h2",{id:"quick-start"},"Quick start"),(0,l.mdx)("ol",null,(0,l.mdx)("li",{parentName:"ol"},"Install ",(0,l.mdx)("inlineCode",{parentName:"li"},"xstate")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"@xstate/test"),":")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-bash"},"npm install xstate @xstate/test\n")),(0,l.mdx)("ol",{start:2},(0,l.mdx)("li",{parentName:"ol"},"Create the machine that will be used to model the system under test (SUT):")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"import { createMachine } from 'xstate';\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: {\n        TOGGLE: 'active'\n      }\n    },\n    active: {\n      on: {\n        TOGGLE: 'inactive'\n      }\n    }\n  }\n});\n")),(0,l.mdx)("ol",{start:3},(0,l.mdx)("li",{parentName:"ol"},"Add assertions for each state in the machine (in this example, using ",(0,l.mdx)("a",{parentName:"li",href:"https://github.com/GoogleChrome/puppeteer"},"Puppeteer"),"):")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"// ...\n\nconst toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {\n      on: {\n        /* ... */\n      },\n      meta: {\n        test: async (page) => {\n          await page.waitFor('input:checked');\n        }\n      }\n    },\n    active: {\n      on: {\n        /* ... */\n      },\n      meta: {\n        test: async (page) => {\n          await page.waitFor('input:not(:checked)');\n        }\n      }\n    }\n  }\n});\n")),(0,l.mdx)("ol",{start:4},(0,l.mdx)("li",{parentName:"ol"},"Create the model:")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"import { createMachine } from 'xstate';\nimport { createModel } from '@xstate/test';\n\nconst toggleMachine = createMachine(/* ... */);\n\nconst toggleModel = createModel(toggleMachine).withEvents({\n  TOGGLE: {\n    exec: async (page) => {\n      await page.click('input');\n    }\n  }\n});\n")),(0,l.mdx)("ol",{start:5},(0,l.mdx)("li",{parentName:"ol"},"Create test plans and run the tests with coverage:")),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"// ...\n\ndescribe('toggle', () => {\n  const testPlans = toggleModel.getShortestPathPlans();\n\n  testPlans.forEach((plan) => {\n    describe(plan.description, () => {\n      plan.paths.forEach((path) => {\n        it(path.description, async () => {\n          // do any setup, then...\n\n          await path.test(page);\n        });\n      });\n    });\n  });\n\n  it('should have full coverage', () => {\n    return toggleModel.testCoverage();\n  });\n});\n")),(0,l.mdx)("h2",{id:"api"},"API"),(0,l.mdx)("h3",{id:"createmodelmachine-options"},(0,l.mdx)("inlineCode",{parentName:"h3"},"createModel(machine, options?)")),(0,l.mdx)("p",null,"Creates an abstract testing model based on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"machine")," passed in."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Argument"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"machine")),(0,l.mdx)("td",{parentName:"tr",align:null},"StateMachine"),(0,l.mdx)("td",{parentName:"tr",align:null},"The machine used to create the abstract model.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"options?")),(0,l.mdx)("td",{parentName:"tr",align:null},"TestModelOptions"),(0,l.mdx)("td",{parentName:"tr",align:null},"Options to customize the abstract model")))),(0,l.mdx)("h4",{id:"returns"},"Returns"),(0,l.mdx)("p",null,"A ",(0,l.mdx)("inlineCode",{parentName:"p"},"TestModel")," instance."),(0,l.mdx)("h3",{id:"methods"},"Methods"),(0,l.mdx)("h4",{id:"modelwitheventseventsmap"},(0,l.mdx)("inlineCode",{parentName:"h4"},"model.withEvents(eventsMap)")),(0,l.mdx)("p",null,"Provides testing details for each event. Each key in ",(0,l.mdx)("inlineCode",{parentName:"p"},"eventsMap")," is an object whose keys are event types and properties describe the execution and test cases for each event:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"exec")," (function): Function that executes the events. It is given two arguments:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"testContext")," (any): any contextual testing data"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"event")," (EventObject): the event sent by the testing model"))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"cases?")," (EventObject[]): the sample event objects for this event type that can be sent by the testing model.")),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"const toggleModel = createModel(toggleMachine).withEvents({\n  TOGGLE: {\n    exec: async (page) => {\n      await page.click('input');\n    }\n  }\n});\n")),(0,l.mdx)("h3",{id:"testmodelgetshortestpathplansoptions"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testModel.getShortestPathPlans(options?)")),(0,l.mdx)("p",null,"Returns an array of testing plans based on the shortest paths from the test model\u2019s initial state to every other reachable state."),(0,l.mdx)("h4",{id:"options"},"Options"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Argument"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"filter")),(0,l.mdx)("td",{parentName:"tr",align:null},"function"),(0,l.mdx)("td",{parentName:"tr",align:null},"Takes in the ",(0,l.mdx)("inlineCode",{parentName:"td"},"state")," and returns ",(0,l.mdx)("inlineCode",{parentName:"td"},"true")," if the state should be traversed, or ",(0,l.mdx)("inlineCode",{parentName:"td"},"false")," if traversal should stop.")))),(0,l.mdx)("p",null,"This is useful for preventing infinite traversals and stack overflow errors:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"const todosModel = createModel(todosMachine).withEvents({\n  /* ... */\n});\n\nconst plans = todosModel.getShortestPathPlans({\n  // Tell the algorithm to limit state/event adjacency map to states\n  // that have less than 5 todos\n  filter: (state) => state.context.todos.length < 5\n});\n")),(0,l.mdx)("h3",{id:"testmodelgetsimplepathplansoptions"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testModel.getSimplePathPlans(options?)")),(0,l.mdx)("p",null,"Returns an array of testing plans based on the simple paths from the test model\u2019s initial state to every other reachable state."),(0,l.mdx)("h4",{id:"options-1"},"Options"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Argument"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"filter")),(0,l.mdx)("td",{parentName:"tr",align:null},"function"),(0,l.mdx)("td",{parentName:"tr",align:null},"Takes in the ",(0,l.mdx)("inlineCode",{parentName:"td"},"state")," and returns ",(0,l.mdx)("inlineCode",{parentName:"td"},"true")," if the state should be traversed, or ",(0,l.mdx)("inlineCode",{parentName:"td"},"false")," if traversal should stop.")))),(0,l.mdx)("h3",{id:"testmodelgetplanfromeventsevents-options"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testModel.getPlanFromEvents(events, options)")),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Argument"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"events")),(0,l.mdx)("td",{parentName:"tr",align:null},"EventObject[]"),(0,l.mdx)("td",{parentName:"tr",align:null},"The sequence of events to create the plan")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"options")),(0,l.mdx)("td",{parentName:"tr",align:null},"{ target: string }"),(0,l.mdx)("td",{parentName:"tr",align:null},"An object with a ",(0,l.mdx)("inlineCode",{parentName:"td"},"target")," property that should match the target state of the events")))),(0,l.mdx)("p",null,"Returns an array with a single testing plan with a single path generated from the ",(0,l.mdx)("inlineCode",{parentName:"p"},"events"),"."),(0,l.mdx)("p",null,"Throws an error if the last entered state does not match the ",(0,l.mdx)("inlineCode",{parentName:"p"},"options.target"),"."),(0,l.mdx)("h3",{id:"testmodeltestcoverageoptions"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testModel.testCoverage(options?)")),(0,l.mdx)("p",null,"Tests that all state nodes were covered (traversed) in the exected tests."),(0,l.mdx)("h4",{id:"options-2"},"Options"),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Argument"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("inlineCode",{parentName:"td"},"filter")),(0,l.mdx)("td",{parentName:"tr",align:null},"function"),(0,l.mdx)("td",{parentName:"tr",align:null},"Takes in each ",(0,l.mdx)("inlineCode",{parentName:"td"},"stateNode")," and returns ",(0,l.mdx)("inlineCode",{parentName:"td"},"true")," if that state node should have been covered.")))),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-js"},"// Only test coverage for state nodes with a `.meta` property defined:\n\ntestModel.testCoverage({\n  filter: (stateNode) => !!stateNode.meta\n});\n")),(0,l.mdx)("h3",{id:"testplandescription"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testPlan.description")),(0,l.mdx)("p",null,"The string description of the testing plan, describing the goal of reaching the ",(0,l.mdx)("inlineCode",{parentName:"p"},"testPlan.state"),"."),(0,l.mdx)("h3",{id:"testplanpaths"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testPlan.paths")),(0,l.mdx)("p",null,"The testing paths to get from the test model\u2019s initial state to every other reachable state."),(0,l.mdx)("h3",{id:"testpathdescription"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testPath.description")),(0,l.mdx)("p",null,"The string description of the testing path, describing a sequence of events that will reach the ",(0,l.mdx)("inlineCode",{parentName:"p"},"testPath.state"),"."),(0,l.mdx)("h3",{id:"testpathtesttestcontext"},(0,l.mdx)("inlineCode",{parentName:"h3"},"testPath.test(testContext)")),(0,l.mdx)("p",null,"Executes each step in ",(0,l.mdx)("inlineCode",{parentName:"p"},"testPath.segments")," by:"),(0,l.mdx)("ol",null,(0,l.mdx)("li",{parentName:"ol"},"Verifying that the SUT is in ",(0,l.mdx)("inlineCode",{parentName:"li"},"segment.state")),(0,l.mdx)("li",{parentName:"ol"},"Executing the event for ",(0,l.mdx)("inlineCode",{parentName:"li"},"segment.event"))),(0,l.mdx)("p",null,"And finally, verifying that the SUT is in the target ",(0,l.mdx)("inlineCode",{parentName:"p"},"testPath.state"),"."),(0,l.mdx)("p",null,"NOTE: If your model has nested states, the ",(0,l.mdx)("inlineCode",{parentName:"p"},"meta.test")," method for each parent state of that nested state is also executed when verifying that the SUT is in that nested state."))}p.isMDXComponent=!0}}]);