"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[36025],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>d,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),m=function(e){return function(t){var n=c(t.components);return a.createElement(e,r({},t,{components:n}))}},c=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(n),p=i,u=m["".concat(s,".").concat(p)]||m[p]||h[p]||r;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var d=2;d<r;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},53485:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>v,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=n(87462),i=(n(67294),n(3905));const r={title:"Events and transitions"},s=void 0,o={unversionedId:"transitions",id:"transitions",title:"Events and transitions",description:"A transition is a change from one finite state to another, triggered by an event.",source:"@site/docs/transitions.mdx",sourceDirName:".",slug:"/transitions",permalink:"/docs/transitions",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/transitions.mdx",tags:[],version:"current",frontMatter:{title:"Events and transitions"},sidebar:"docs",previous:{title:"Input",permalink:"/docs/input"},next:{title:"Eventless (always) transitions",permalink:"/docs/eventless-transitions"}},l={},d=[{value:"Using transitions and events in Stately Studio",id:"using-transitions-and-events-in-stately-studio",level:2},{value:"Add a transition and event",id:"add-a-transition-and-event",level:3},{value:"Change the source and target states for a transition or event",id:"change-the-source-and-target-states-for-a-transition-or-event",level:3},{value:"On the canvas",id:"on-the-canvas",level:4},{value:"Dragging the transition handles",id:"dragging-the-transition-handles",level:4},{value:"Using the transition details panel",id:"using-the-transition-details-panel",level:4},{value:"Event objects",id:"event-objects",level:2},{value:"Selecting transitions",id:"selecting-transitions",level:2},{value:"Self-transitions",id:"self-transitions",level:2},{value:"Using self-transitions in Stately Studio",id:"using-self-transitions-in-stately-studio",level:3},{value:"Make an event into a self-transition",id:"make-an-event-into-a-self-transition",level:4},{value:"On the canvas",id:"on-the-canvas-1",level:5},{value:"Dragging the transition arrow",id:"dragging-the-transition-arrow",level:5},{value:"Transitions between states",id:"transitions-between-states",level:2},{value:"Parent to child transitions",id:"parent-to-child-transitions",level:2},{value:"Re-entering",id:"re-entering",level:2},{value:"Transitions to any state",id:"transitions-to-any-state",level:2},{value:"Forbidden transitions",id:"forbidden-transitions",level:2},{value:"Wildcard transitions",id:"wildcard-transitions",level:2},{value:"Partial wildcard transitions",id:"partial-wildcard-transitions",level:2},{value:"Valid wildcard examples",id:"valid-wildcard-examples",level:3},{value:"Invalid wildcard",id:"invalid-wildcard",level:3},{value:"Multiple transitions in parallel states",id:"multiple-transitions-in-parallel-states",level:2},{value:"Other transitions",id:"other-transitions",level:2},{value:"Transition descriptions",id:"transition-descriptions",level:2},{value:"Shorthands",id:"shorthands",level:2},{value:"TypeScript",id:"typescript",level:2},{value:"Cheatsheet",id:"cheatsheet",level:2},{value:"Event objects",id:"event-objects-1",level:3},{value:"Transition targets",id:"transition-targets",level:3}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.mdx)("div",t)},c=m("EmbedMachine"),p=m("SkipDownLink"),h=m("Plus"),u=m("MoreHorizontal"),g=m("Info"),x={toc:d};function v(e){let{components:t,...n}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},x,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("p",null,"A ",(0,i.mdx)("strong",{parentName:"p"},"transition")," is a change from one finite state to another, triggered by an event."),(0,i.mdx)("p",null,"An ",(0,i.mdx)("strong",{parentName:"p"},"event")," is a signal, trigger, or message that causes a transition. When an actor receives an event, its machine will determine if there are any enabled transitions for that event in the current state. If enabled transitions exist, the machine will take them and execute their actions."),(0,i.mdx)(c,{name:"Video player",embedURL:"https://stately.ai/registry/editor/embed/e13bef2b-bb13-4465-96ac-0bc25340688e?machineId=9630e3b7-9f8e-4dc9-8b55-661f854d28b7",mdxType:"EmbedMachine"}),(0,i.mdx)("p",null,"Transitions are \u201cdeterministic\u201d; each combination of state and event always points to the same next state. When a state machine receives an event, only the active finite states are checked to see if any of them have a transition for that event. Those transitions are called ",(0,i.mdx)("strong",{parentName:"p"},"enabled transitions"),". If there is an enabled transition, the state machine will execute the transition's actions, and then transition to the target state."),(0,i.mdx)("p",null,"Transitions are represented by ",(0,i.mdx)("inlineCode",{parentName:"p"},"on:")," in a state:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\nconst feedbackMachine = createMachine({\n  id: 'feedback',\n  initial: 'question',\n  states: {\n    question: {\n      on: {\n        'feedback.good': {\n          target: 'thanks'\n        }\n      }\n    }\n    thanks: {}\n  },\n});\n")),(0,i.mdx)(p,{text:"Jump to learning more about event objects in XState",link:"#event-objects",mdxType:"SkipDownLink"}),(0,i.mdx)("h2",{id:"using-transitions-and-events-in-stately-studio"},"Using transitions and events in Stately Studio"),(0,i.mdx)("p",null,"The arrows are transitions, and the rounded rectangles on the arrow\u2019s lines are events. Each transition has a ",(0,i.mdx)("strong",{parentName:"p"},"source")," state which comes before the transition, and a ",(0,i.mdx)("strong",{parentName:"p"},"target")," state, which comes after the transition. The transition\u2019s arrow starts from the source state and points to the target state."),(0,i.mdx)("h3",{id:"add-a-transition-and-event"},"Add a transition and event"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Select an existing state."),(0,i.mdx)("li",{parentName:"ol"},"Press or drag from one of the ",(0,i.mdx)(h,{size:18,mdxType:"Plus"})," handles on the left, right and bottom sides of the selected state, and release to create a connecting transition, event and new state.")),(0,i.mdx)("h3",{id:"change-the-source-and-target-states-for-a-transition-or-event"},"Change the source and target states for a transition or event"),(0,i.mdx)("p",null,"First select the transition or event you want to change. Then\u2026"),(0,i.mdx)("h4",{id:"on-the-canvas"},"On the canvas"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Right-click the transition or event, or use the ",(0,i.mdx)(u,{size:18,mdxType:"MoreHorizontal"})," triple dot icon button, to open the Edit menu."),(0,i.mdx)("li",{parentName:"ol"},"Choose ",(0,i.mdx)("strong",{parentName:"li"},"Switch source and target"),".")),(0,i.mdx)("h4",{id:"dragging-the-transition-handles"},"Dragging the transition handles"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Drag the transition\u2019s handle connected to the source state to connect it to a new source state."),(0,i.mdx)("li",{parentName:"ol"},"Drag the transition\u2019s handle connected to the target state to connect it to a new target state.")),(0,i.mdx)("h4",{id:"using-the-transition-details-panel"},"Using the transition details panel"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Open the transition ",(0,i.mdx)(g,{size:18,mdxType:"Info"})," ",(0,i.mdx)("strong",{parentName:"li"},"Details")," panel from the right tool menu."),(0,i.mdx)("li",{parentName:"ol"},"Choose a new source state from the ",(0,i.mdx)("strong",{parentName:"li"},"Source")," dropdown options."),(0,i.mdx)("li",{parentName:"ol"},"Choose a new target state from the ",(0,i.mdx)("strong",{parentName:"li"},"Target")," dropdown options.")),(0,i.mdx)("h2",{id:"event-objects"},"Event objects"),(0,i.mdx)("p",null,"In XState, events are represented by event objects with a ",(0,i.mdx)("inlineCode",{parentName:"p"},"type")," property and optional payload:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The ",(0,i.mdx)("inlineCode",{parentName:"li"},"type")," property is a string that represents the event type."),(0,i.mdx)("li",{parentName:"ul"},"The payload is an object that contains additional data about the event.")),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"feedbackActor.send({\n  // The event type\n  type: 'feedback.update',\n  // Additional payload\n  feedback: 'This is great!',\n  rating: 5,\n});\n")),(0,i.mdx)("h2",{id:"selecting-transitions"},"Selecting transitions"),(0,i.mdx)("p",null,"Transitions are selected by checking the deepest child states first. If the transition is enabled (i.e. if its guard passes), it will be taken. If not, the parent state will be checked, and so on."),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Start on the deepest active state nodes (aka atomic state nodes)"),(0,i.mdx)("li",{parentName:"ol"},"If the transition is enabled (no ",(0,i.mdx)("inlineCode",{parentName:"li"},"guard")," or its ",(0,i.mdx)("inlineCode",{parentName:"li"},"guard")," evaluates to ",(0,i.mdx)("inlineCode",{parentName:"li"},"true"),"), select it."),(0,i.mdx)("li",{parentName:"ol"},"If no transition is enabled, go up to the parent state node and repeat step 1."),(0,i.mdx)("li",{parentName:"ol"},"Finally, if no transitions are enabled, no transitions will be taken, and the state will not change.")),(0,i.mdx)("h2",{id:"self-transitions"},"Self-transitions"),(0,i.mdx)("p",null,"A state can transition to itself. This is known as a ",(0,i.mdx)("strong",{parentName:"p"},"self-transition"),", and is useful for changing context and/or executing actions without changing the finite state. You can also use self-transitions to restart a state."),(0,i.mdx)("h3",{id:"using-self-transitions-in-stately-studio"},"Using self-transitions in Stately Studio"),(0,i.mdx)("h4",{id:"make-an-event-into-a-self-transition"},"Make an event into a self-transition"),(0,i.mdx)("h5",{id:"on-the-canvas-1"},"On the canvas"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Right-click the event to open the edit menu."),(0,i.mdx)("li",{parentName:"ol"},"Choose ",(0,i.mdx)("strong",{parentName:"li"},"Make self transition")," from the edit menu.")),(0,i.mdx)("h5",{id:"dragging-the-transition-arrow"},"Dragging the transition arrow"),(0,i.mdx)("ol",null,(0,i.mdx)("li",{parentName:"ol"},"Select the event."),(0,i.mdx)("li",{parentName:"ol"},"Grab the circular handle at the arrow end of the transition and drag the handle to connect it back to the source state.")),(0,i.mdx)("h2",{id:"transitions-between-states"},"Transitions between states"),(0,i.mdx)("p",null,"Usually, transitions are between two sibling states. These transitions are defined by setting the ",(0,i.mdx)("inlineCode",{parentName:"p"},"target")," as the sibling state key."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  // ...\n  states: {\n    form: {\n      on: {\n        submit: {\n          // highlight-start\n          // Target is the key of the sibling state\n          target: 'submitting',\n          // highlight-end\n        },\n      },\n    },\n    // highlight-next-line\n    submitting: {\n      // ...\n    },\n  },\n});\n")),(0,i.mdx)("p",null,"Coming soon\u2026 assign example"),(0,i.mdx)("h2",{id:"parent-to-child-transitions"},"Parent to child transitions"),(0,i.mdx)("p",null,"When a state machine receives an event, it will first check the deepest (",(0,i.mdx)("a",{parentName:"p",href:"/docs/state-machines-and-statecharts#atomic-states"},"atomic"),") state to see if there is any enabled transition. If not, the parent state is checked, and so on, until the machine reaches the root state."),(0,i.mdx)("p",null,"When you want an event to transition to a state regardless of which sibling state is active, a useful pattern is to transition from the parent state to the child state."),(0,i.mdx)("p",null,"Coming soon\u2026 example with ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ on: { target: '.child' } }")),(0,i.mdx)("h2",{id:"re-entering"},"Re-entering"),(0,i.mdx)("p",null,"By default, when a state machine transitions from a parent state to the same parent state or a descendent (child or deeper), it will not re-enter the parent state; that is, it will not execute the ",(0,i.mdx)("a",{parentName:"p",href:"/docs/actions"},(0,i.mdx)("inlineCode",{parentName:"a"},"exit")," and ",(0,i.mdx)("inlineCode",{parentName:"a"},"entry")," actions")," of the parent state."),(0,i.mdx)("p",null,"If you want the parent state to be re-entered, you can set the ",(0,i.mdx)("inlineCode",{parentName:"p"},"reenter")," property to ",(0,i.mdx)("inlineCode",{parentName:"p"},"true"),". This will cause the parent state to re-enter, executing the ",(0,i.mdx)("inlineCode",{parentName:"p"},"exit")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"entry")," actions of the parent state."),(0,i.mdx)("admonition",{type:"tip"},(0,i.mdx)("p",{parentName:"admonition"},"In XState v4, re-entering transitions were known as ",(0,i.mdx)("strong",{parentName:"p"},"external transitions"),", and the default transitions were known as ",(0,i.mdx)("strong",{parentName:"p"},"internal transitions"),".")),(0,i.mdx)("p",null,"Coming soon\u2026 illustration showing no re-enter vs. re-enter"),(0,i.mdx)("p",null,"Coming soon\u2026 example with ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ target: '.child', reenter: true }")),(0,i.mdx)("h2",{id:"transitions-to-any-state"},"Transitions to any state"),(0,i.mdx)("p",null,"Sibling descendent states: ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ target: 'sibling.child.grandchild' }")),(0,i.mdx)("p",null,"Parent to descendent states: ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ target: '.child.grandchild' }")),(0,i.mdx)("p",null,"State to any state: ",(0,i.mdx)("inlineCode",{parentName:"p"},"{ target: '#specificState' }")),(0,i.mdx)("h2",{id:"forbidden-transitions"},"Forbidden transitions"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("inlineCode",{parentName:"li"},"{ on: { forbidden: {} } }")),(0,i.mdx)("li",{parentName:"ul"},"Different than omitting the transition; transition selection algorithm will stop looking"),(0,i.mdx)("li",{parentName:"ul"},"Same as ",(0,i.mdx)("inlineCode",{parentName:"li"},"{ on: { forbidden: { target: undefined } } }"))),(0,i.mdx)("h2",{id:"wildcard-transitions"},"Wildcard transitions"),(0,i.mdx)("p",null,"A wildcard transition is a transition that will match any event. The event descriptor (key of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"on: {...}")," object) is defined using the ",(0,i.mdx)("inlineCode",{parentName:"p"},"*")," wildcard character as the event type:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'asleep',\n  states: {\n    asleep: {\n      on: {\n        // highlight-start\n        // This transition will match any event\n        '*': { target: 'awake' },\n        // highlight-end\n      },\n    },\n    awake: {},\n  },\n});\n")),(0,i.mdx)("p",null,"Wildcard transitions are useful for:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"handling events that are not handled by any other transition."),(0,i.mdx)("li",{parentName:"ul"},"as a \u201ccatch-all\u201d transition that handles any event in a state.")),(0,i.mdx)("p",null,"A wildcard transition has the least priority; it will only be taken if no other transitions are enabled."),(0,i.mdx)("h2",{id:"partial-wildcard-transitions"},"Partial wildcard transitions"),(0,i.mdx)("p",null,"A partial wildcard transition is a transition that matches any event that starts with a specific prefix. The event descriptor is defined by using the wildcard character (",(0,i.mdx)("inlineCode",{parentName:"p"},"*"),") after a dot (",(0,i.mdx)("inlineCode",{parentName:"p"},"."),") as the event type:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      on: {\n        // highlight-start\n        // This will match any event that starts with 'feedback.':\n        // 'feedback.good', 'feedback.bad', etc.\n        'feedback.*': { target: 'form' },\n        // highlight-end\n      },\n    },\n    form: {},\n    // ...\n  },\n});\n")),(0,i.mdx)("p",null,"The wildcard character (",(0,i.mdx)("inlineCode",{parentName:"p"},"*"),") can only be used in the suffix of an event descriptor, following a dot (",(0,i.mdx)("inlineCode",{parentName:"p"},"."),"):"),(0,i.mdx)("h3",{id:"valid-wildcard-examples"},"Valid wildcard examples"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"check mark button"},"\u2705")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"mouse.*"),": matches ",(0,i.mdx)("inlineCode",{parentName:"li"},"mouse.click"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"mouse.move"),", etc."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"check mark button"},"\u2705")," ",(0,i.mdx)("inlineCode",{parentName:"li"},"mouse.click.*"),": matches ",(0,i.mdx)("inlineCode",{parentName:"li"},"mouse.click.left"),", ",(0,i.mdx)("inlineCode",{parentName:"li"},"mouse.click.right"),", etc.")),(0,i.mdx)("h3",{id:"invalid-wildcard"},"Invalid wildcard"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"prohibited"},"\ud83d\udeab")," ",(0,i.mdx)("del",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"del"},"mouse*")),": invalid; does not match any event."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"prohibited"},"\ud83d\udeab")," ",(0,i.mdx)("del",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"del"},"mouse.*.click")),": invalid; ",(0,i.mdx)("inlineCode",{parentName:"li"},"*")," cannot be used in the middle of an event descriptor."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"prohibited"},"\ud83d\udeab")," ",(0,i.mdx)("del",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"del"},"*.click")),": invalid; ",(0,i.mdx)("inlineCode",{parentName:"li"},"*")," cannot be used in the prefix of an event descriptor."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"prohibited"},"\ud83d\udeab")," ",(0,i.mdx)("del",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"del"},"mouse.click*")),": invalid; does not match any event."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("span",{parentName:"li",role:"img","aria-label":"prohibited"},"\ud83d\udeab")," ",(0,i.mdx)("del",{parentName:"li"},(0,i.mdx)("inlineCode",{parentName:"del"},"mouse.*.*")),": invalid; ",(0,i.mdx)("inlineCode",{parentName:"li"},"*")," cannot be used in the middle of an event descriptor.")),(0,i.mdx)("h2",{id:"multiple-transitions-in-parallel-states"},"Multiple transitions in parallel states"),(0,i.mdx)("p",null,"Since parallel states have multiple regions that can be active at the same time, it is possible for multiple transitions to be enabled at the same time. In this case, all enabled transitions to these regions will be taken."),(0,i.mdx)("p",null,"Multiple targets are specified as an array of strings:"),(0,i.mdx)("p",null,"Coming soon\u2026 example."),(0,i.mdx)("h2",{id:"other-transitions"},"Other transitions"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/docs/eventless-transitions"},(0,i.mdx)("strong",{parentName:"a"},"Eventless (always) transitions"))," are transitions without events. These transitions are\xa0",(0,i.mdx)("em",{parentName:"li"},"always"),"\xa0taken after any transition in their state is enabled."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("a",{parentName:"li",href:"/docs/delayed-transitions"},(0,i.mdx)("strong",{parentName:"a"},"Delayed (after) transitions"))," are transitions that are enabled after a specified duration.")),(0,i.mdx)("h2",{id:"transition-descriptions"},"Transition descriptions"),(0,i.mdx)("p",null,"You can add a ",(0,i.mdx)("inlineCode",{parentName:"p"},".description")," string to a transition to describe the transition. This is useful for explaining the purpose of the transition in the visualized state machine."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  // ...\n  on: {\n    exit: {\n      // highlight-next-line\n      description: 'Closes the feedback form',\n      target: '.closed',\n    },\n  },\n});\n")),(0,i.mdx)("h2",{id:"shorthands"},"Shorthands"),(0,i.mdx)("p",null,"If the transition only specifies a ",(0,i.mdx)("inlineCode",{parentName:"p"},"target"),", then the string target can be used as a shorthand instead of the entire transition object:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst feedbackMachine = createMachine({\n  initial: 'prompt',\n  states: {\n    prompt: {\n      on: {\n        // highlight-start\n        // This is shorthand for:\n        // 'feedback': { target: 'form' }\n        'feedback.good': 'thanks',\n        // highlight-end\n      },\n    },\n    thanks: {},\n    // ...\n  },\n});\n")),(0,i.mdx)("p",null,"Using the string target shorthand is useful for quickly prototyping state machines. Generally, we recommended using the full transition object syntax as it will be consistent with all other transition objects and will be easier to add actions, guards, and other properties to the transition in the future."),(0,i.mdx)("h2",{id:"typescript"},"TypeScript"),(0,i.mdx)("p",null,"Transitions mainly use the event type that they are enabled by."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const machine = createMachine({\n  types: {} as {\n    events: { type: 'greet'; message: string } | { type: 'submit' };\n  },\n  // ...\n  on: {\n    greet: {\n      actions: ({ event }) => {\n        event.type; // 'greet'\n        event.message; // string\n      },\n    },\n  },\n});\n")),(0,i.mdx)("h2",{id:"cheatsheet"},"Cheatsheet"),(0,i.mdx)("p",null,"Use our XState events and transitions cheatsheet below to get started quickly."),(0,i.mdx)("h3",{id:"event-objects-1"},"Event objects"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"feedbackActor.send({\n  // Event type\n  type: 'feedback.update',\n  // Event payload\n  feedback: 'A+ would use state machines again',\n  rating: 5,\n});\n")),(0,i.mdx)("h3",{id:"transition-targets"},"Transition targets"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"const machine = createMachine({\n  initial: 'a',\n  states: {\n    a: {\n      on: {\n        // Sibling target\n        event: {\n          target: 'b',\n        },\n        // Sibling child target\n        otherEvent: {\n          target: 'b.c',\n        },\n      },\n    },\n    b: {\n      on: {\n        // ID target\n        event: {\n          target: '#c',\n        },\n      },\n    },\n    c: {\n      id: 'c',\n      on: {\n        // Child target\n        event: {\n          target: '.child',\n        },\n      },\n      initial: 'child',\n      states: {\n        child: {},\n      },\n    },\n  },\n  on: {\n    // Child target\n    someEvent: {\n      target: '.b',\n    },\n  },\n});\n")))}v.isMDXComponent=!0}}]);