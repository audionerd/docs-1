"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[84231],{3905:(e,t,r)=>{r.r(t),r.d(t,{MDXContext:()=>l,MDXProvider:()=>m,mdx:()=>h,useMDXComponents:()=>d,withMDXComponents:()=>p});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var a in r)Object.prototype.hasOwnProperty.call(r,a)&&(e[a]=r[a])}return e},s.apply(this,arguments)}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),p=function(e){return function(t){var r=d(t.components);return a.createElement(e,s({},t,{components:r}))}},d=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},m=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(r),m=n,g=p["".concat(o,".").concat(m)]||p[m]||u[m]||s;return r?a.createElement(g,i(i({ref:t},l),{},{components:r})):a.createElement(g,i({ref:t},l))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=r.length,o=new Array(s);o[0]=g;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var l=2;l<s;l++)o[l]=r[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}g.displayName="MDXCreateElement"},7374:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=r(87462),n=(r(67294),r(3905));const s={title:"Persistence"},o=void 0,i={unversionedId:"persistence",id:"persistence",title:"Persistence",description:"Actors can persist their internal state and restore it later. Persistence refers to storing the state of an actor in persistent storage, such as localStorage or a database. Restoration refers to restoring the state of an actor from persistent storage.",source:"@site/docs/persistence.mdx",sourceDirName:".",slug:"/persistence",permalink:"/docs/persistence",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/persistence.mdx",tags:[],version:"current",frontMatter:{title:"Persistence"},sidebar:"docs",previous:{title:"History states",permalink:"/docs/history-states"},next:{title:"Tags",permalink:"/docs/tags"}},c={},l=[{value:"Persisting state",id:"persisting-state",level:2},{value:"Restoring state",id:"restoring-state",level:2},{value:"Deep persistence",id:"deep-persistence",level:2},{value:"Event sourcing",id:"event-sourcing",level:2},{value:"Strategies",id:"strategies",level:2},{value:"Caveats",id:"caveats",level:2},{value:"TypeScript",id:"typescript",level:2},{value:"Cheatsheet",id:"cheatsheet",level:2},{value:"Resources",id:"resources",level:2}],p={toc:l};function d(e){let{components:t,...r}=e;return(0,n.mdx)("wrapper",(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.mdx)("p",null,"Actors can persist their internal state and restore it later. ",(0,n.mdx)("strong",{parentName:"p"},"Persistence")," refers to storing the state of an actor in persistent storage, such as localStorage or a database. ",(0,n.mdx)("strong",{parentName:"p"},"Restoration")," refers to restoring the state of an actor from persistent storage."),(0,n.mdx)("p",null,"In frontend applications, persistence is useful for maintaining state across browser reloads. In backend applications, persistence allows workflows to span multiple requests, survive service restarts, be fault-tolerant, represent long-running processes, and be auditable & traceable."),(0,n.mdx)("p",null,"In XState, you can obtain the state to be persisted via ",(0,n.mdx)("inlineCode",{parentName:"p"},"actor.getPersistedState()")," and restore state via ",(0,n.mdx)("inlineCode",{parentName:"p"},"createActor(behavior, { state: restoredState }).start()"),":"),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackActor = createActor(feedbackMachine).start();\n\n// Get state to be persisted\nconst persistedState = feedbackActor.getPersistedState();\n\n// Persist state\nlocalStorage.setItem('feedback', JSON.stringify(persistedState));\n\n// Restore state\nconst restoredState = JSON.parse(localStorage.getItem('feedback'));\n\nconst restoredFeedbackActor = createActor(feedbackMachine, {\n  state: restoredState,\n}).start();\n")),(0,n.mdx)("h2",{id:"persisting-state"},"Persisting state"),(0,n.mdx)("p",null,"You can obtain the state to be persisted via ",(0,n.mdx)("inlineCode",{parentName:"p"},"actor.getPersistedState()"),":"),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackActor = createActor(feedbackMachine).start();\n\n// Get state to be persisted\nconst persistedState = feedbackActor.getPersistedState();\n")),(0,n.mdx)("p",null,"The internal state can be persisted from any actor, not only machines. Note that the persisted state is ",(0,n.mdx)("em",{parentName:"p"},"not")," the same as the snapshot from ",(0,n.mdx)("inlineCode",{parentName:"p"},"actor.getSnapshot()"),"; persisted state represents the internal state of the actor, while snapshots represent the actor's last emitted value:"),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"const promiseActor = fromPromise(() => Promise.resolve(42));\n\n// Get the last emitted value\nconst snapshot = promiseActor.getSnapshot();\nconsole.log(snapshot);\n// logs 42\n\n// Get the persisted state\nconst persistedState = promiseActor.getPersistedState();\nconsole.log(persistedState);\n// logs { status: 'done', data: 42 }\n")),(0,n.mdx)("h2",{id:"restoring-state"},"Restoring state"),(0,n.mdx)("p",null,"You can restore an actor to a persisted state by passing the persisted state into the ",(0,n.mdx)("inlineCode",{parentName:"p"},"state")," option of the 2nd argument of ",(0,n.mdx)("inlineCode",{parentName:"p"},"createActor(logic, { state: restoredState })"),":"),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"// Get persisted state\nconst restoredState = JSON.parse(localStorage.getItem('feedback'));\n\n// Restore state\nconst feedbackActor = createActor(feedbackMachine, {\n  state: restoredState,\n});\n\nfeedbackActor.start();\n")),(0,n.mdx)("p",null,"Actions from machine actors will ",(0,n.mdx)("em",{parentName:"p"},"not")," be re-executed, because they are assumed to have been already executed. However, invocations will be restarted, and spawned actors will be restored recursively."),(0,n.mdx)("h2",{id:"deep-persistence"},"Deep persistence"),(0,n.mdx)("p",null,"Persisting & restoring state from machine actors is deep; all invoked & spawned actors will be persisted & restored recursively."),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"const feedbackMachine = createMachine({\n  // ...\n  states: {\n    form: {\n      invoke: {\n        id: 'form',\n        src: formMachine,\n      },\n    },\n  },\n});\n\nconst feedbackActor = createActor(feedbackMachine).start();\n\n// Persist state\nconst persistedState = feedbackActor.getPersistedState();\nlocalStorage.setItem('feedback', JSON.stringify(persistedState));\n\n//  ...\n\n// Restore state\nconst restoredState = JSON.parse(localStorage.getItem('feedback'));\n\nconst restoredFeedbackActor = createActor(feedbackMachine, {\n  state: restoredState,\n}).start();\n// Will restore both the feedbackActor and the invoked form actor at\n// their persisted states\n")),(0,n.mdx)("h2",{id:"event-sourcing"},"Event sourcing"),(0,n.mdx)("p",null,"An alternative to persisting state is ",(0,n.mdx)("strong",{parentName:"p"},"event sourcing"),", which is a way of restoring the state of an actor by replaying the events that led to that state. Event sourcing can be more reliable than persisting state, because it is less prone to ",(0,n.mdx)("a",{parentName:"p",href:"#caveats"},"incompatible state"),"."),(0,n.mdx)("p",null,"To implement event sourcing, you persist the events as they happen, and then replay them to restore the state of the actor:"),(0,n.mdx)("p",null,(0,n.mdx)("em",{parentName:"p"},"Code example coming soon")),(0,n.mdx)("ul",null,(0,n.mdx)("li",{parentName:"ul"},"Useful for replaying actions")),(0,n.mdx)("h2",{id:"strategies"},"Strategies"),(0,n.mdx)("ul",null,(0,n.mdx)("li",{parentName:"ul"},"Storage",(0,n.mdx)("ul",{parentName:"li"},(0,n.mdx)("li",{parentName:"ul"},"Localstorage"),(0,n.mdx)("li",{parentName:"ul"},"DB"),(0,n.mdx)("li",{parentName:"ul"},"Cookies"),(0,n.mdx)("li",{parentName:"ul"},"Filesystem"),(0,n.mdx)("li",{parentName:"ul"},"URL")))),(0,n.mdx)("h2",{id:"caveats"},"Caveats"),(0,n.mdx)("p",null,"There are some caveats to persisting & restoring state that you should be aware of:"),(0,n.mdx)("ul",null,(0,n.mdx)("li",{parentName:"ul"},"Incompatible state: if the machine or actor logic changes, the restored state may be incompatible with the new logic."),(0,n.mdx)("li",{parentName:"ul"},"Replaying actions: actions that have already been executed will not be re-executed. ","[Event sourcing]"," is preferred for this use-case."),(0,n.mdx)("li",{parentName:"ul"},"Serialization: the state must be serializable, which means that it must be JSON-serializable. This means that you cannot persist functions, classes, or other non-serializable values.")),(0,n.mdx)("h2",{id:"typescript"},"TypeScript"),(0,n.mdx)("p",null,(0,n.mdx)("em",{parentName:"p"},"Coming soon")),(0,n.mdx)("h2",{id:"cheatsheet"},"Cheatsheet"),(0,n.mdx)("p",null,(0,n.mdx)("strong",{parentName:"p"},"Persisting state")),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"const persistedState = actor.getPersistedState();\n")),(0,n.mdx)("p",null,(0,n.mdx)("strong",{parentName:"p"},"Restoring state")),(0,n.mdx)("pre",null,(0,n.mdx)("code",{parentName:"pre",className:"language-ts"},"const restoredState = JSON.parse(localStorage.getItem('feedback'));\n\nconst restoredActor = createActor(actorMachine, {\n  state: restoredState,\n}).start();\n")),(0,n.mdx)("h2",{id:"resources"},"Resources"),(0,n.mdx)("p",null,(0,n.mdx)("em",{parentName:"p"},"Coming soon")))}d.isMDXComponent=!0}}]);