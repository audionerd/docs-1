"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[20281],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>c,MDXProvider:()=>d,mdx:()=>h,useMDXComponents:()=>m,withMDXComponents:()=>p});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),p=function(e){return function(n){var t=m(n.components);return a.createElement(e,r({},n,{components:t}))}},m=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=m(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=m(t),d=o,g=p["".concat(i,".").concat(d)]||p[d]||u[d]||r;return t?a.createElement(g,s(s({ref:n},c),{},{components:t})):a.createElement(g,s({ref:n},c))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},632:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const r={title:"Troubleshooting"},i=void 0,s={unversionedId:"xstate/typescript/troubleshooting",id:"version-4/xstate/typescript/troubleshooting",title:"Troubleshooting",description:"There are some known limitations with XState and TypeScript. We love TypeScript, and we\u2019re constantly pressing ahead to make it a better experience in XState.",source:"@site/versioned_docs/version-4/xstate/typescript/troubleshooting.mdx",sourceDirName:"xstate/typescript",slug:"/xstate/typescript/troubleshooting",permalink:"/docs/xstate-v4/xstate/typescript/troubleshooting",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/versioned_docs/version-4/xstate/typescript/troubleshooting.mdx",tags:[],version:"4",frontMatter:{title:"Troubleshooting"},sidebar:"tutorialSidebar",previous:{title:"Type helpers",permalink:"/docs/xstate-v4/xstate/typescript/type-helpers"},next:{title:"Packages",permalink:"/docs/xstate-v4/category/xstate-packages"}},l={},c=[{value:"Events in machine options",id:"events-in-machine-options",level:3},{value:"Event types in entry actions",id:"event-types-in-entry-actions",level:3},{value:"Assign action behaving strangely",id:"assign-action-behaving-strangely",level:3},{value:"<code>keyofStringsOnly</code>",id:"keyofstringsonly",level:3},{value:"Config objects",id:"config-objects",level:3}],p={toc:c};function m(e){let{components:n,...t}=e;return(0,o.mdx)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"There are some known limitations with XState and TypeScript. We love TypeScript, and we\u2019re ",(0,o.mdx)("em",{parentName:"p"},"constantly")," pressing ahead to make it a better experience in XState."),(0,o.mdx)("p",null,"Here are some known issues, all of which have workarounds:"),(0,o.mdx)("h3",{id:"events-in-machine-options"},"Events in machine options"),(0,o.mdx)("p",null,"When you use ",(0,o.mdx)("inlineCode",{parentName:"p"},"createMachine"),", you can pass in implementations to named actions, actors and guards in your config. For example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\ninterface Context {}\n\ntype Event =\n  | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n  | {\n      type: 'EVENT_WITHOUT_FLAG';\n    };\n\ncreateMachine(\n  {\n    schema: {\n      context: {} as Context,\n      events: {} as Event,\n    },\n    on: {\n      EVENT_WITH_FLAG: {\n        actions: 'consoleLogData',\n      },\n    },\n  },\n  {\n    actions: {\n      consoleLogData: (context, event) => {\n        // This will error at .flag\n        console.log(event.flag);\n      },\n    },\n  }\n);\n")),(0,o.mdx)("p",null,"The example above errors because inside the ",(0,o.mdx)("inlineCode",{parentName:"p"},"consoleLogData")," function, XState doesn\u2019t know which event caused it to fire. The cleanest way to manage this issue is to assert the event type yourself:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\ninterface Context {}\n\ntype Event =\n  | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n  | {\n      type: 'EVENT_WITHOUT_FLAG';\n    };\n\nconst config = {\n  schema: {\n    context: {} as Context,\n    events: {} as Event,\n  },\n  on: {\n    EVENT_WITH_FLAG: {\n      actions: 'consoleLogData',\n    },\n  },\n};\n\n\ncreateMachine(config, {\n  actions: {\n    consoleLogData: (context, event) => {\n      if (event.type !== 'EVENT_WITH_FLAG') return;\n      console.log(event.flag);\n    },\n  },\n});\n")),(0,o.mdx)("p",null,"Sometimes it\u2019s also possible to move the implementation inline."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\ninterface Context {}\n\ntype Event =\n  | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n  | {\n      type: 'EVENT_WITHOUT_FLAG';\n    };\n\n\ncreateMachine({\n  schema: {\n    context: {} as Context,\n    events: {} as Event,\n  },\n  on: {\n    EVENT_WITH_FLAG: {\n      actions: (context, event) => {\n        console.log(event.flag);\n\n      },\n    },\n  },\n});\n")),(0,o.mdx)("p",null,"Moving the implementation inline doesn\u2019t work for all cases. The action loses its name, making it uglier in the Visualizer. And if the action is duplicated in several places, you\u2019ll need to copy-paste it to all the required locations."),(0,o.mdx)("h3",{id:"event-types-in-entry-actions"},"Event types in entry actions"),(0,o.mdx)("p",null,"Event types in inline entry actions are not currently typed to the event that led to them. Consider the following example:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\ninterface Context {}\n\ntype Event =\n  | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n  | {\n      type: 'EVENT_WITHOUT_FLAG';\n    };\n\ncreateMachine({\n  schema: {\n    context: {} as Context,\n    events: {} as Event,\n  },\n  initial: 'state1',\n  states: {\n    state1: {\n      on: {\n        EVENT_WITH_FLAG: {\n          target: 'state2',\n        },\n      },\n    },\n    state2: {\n      entry: [\n        (context, event) => {\n          console.log(event.flag);\n        },\n      ],\n    },\n  },\n});\n")),(0,o.mdx)("p",null,"In the example above, XState doesn\u2019t know which event led to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"entry")," action on ",(0,o.mdx)("inlineCode",{parentName:"p"},"state2"),". The only fix similar to the fix for events in machine options above:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\ninterface Context {}\n\ntype Event =\n  | { type: 'EVENT_WITH_FLAG'; flag: boolean }\n  | {\n      type: 'EVENT_WITHOUT_FLAG';\n    };\n\n\ncreateMachine({\n  schema: {\n    context: {} as Context,\n    events: {} as Event,\n  },\n  initial: 'state1',\n  states: {\n    state1: {\n      on: {\n        EVENT_WITH_FLAG: {\n          target: 'state2',\n        },\n      },\n    },\n    state2: {\n      entry: [\n        (context, event) => {\n          // highlight-start\n          if (event.type !== 'EVENT_WITH_FLAG') return;\n          console.log(event.flag);\n          // highlight-end\n        },\n      ],\n    },\n  },\n});\n")),(0,o.mdx)("h3",{id:"assign-action-behaving-strangely"},"Assign action behaving strangely"),(0,o.mdx)("p",null,"When run in ",(0,o.mdx)("inlineCode",{parentName:"p"},"strict: true")," mode, assign actions can sometimes behave strangely."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, assign } from 'xstate';\n\ninterface Context {\n  something: boolean;\n  skip: boolean;\n}\n\ncreateMachine({\n  schema: {\n    context: {} as Context,\n  },\n  entry: [\n    assign({\n      skip: true,\n      something: (context) => context.something,\n    }),\n  ],\n});\n")),(0,o.mdx)("p",null,"In this case, it may appear that nothing you try works and all syntaxes seem buggy. The fix is strange but works consistently: add an unused ",(0,o.mdx)("inlineCode",{parentName:"p"},"context")," argument to the first argument of your assigner function."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, assign } from 'xstate';\n\ninterface Context {\n  something: boolean;\n  skip: boolean;\n}\n\ncreateMachine({\n  schema: {\n    context: {} as Context,\n  },\n  entry: [\n    assign({\n      skip: (context) => true,\n      something: (context) => context.something,\n    }),\n  ],\n});\n")),(0,o.mdx)("p",null,"The assign action issue is a nasty bug to fix and involves moving our codebase to strict mode, which we have planned for XState V5."),(0,o.mdx)("h3",{id:"keyofstringsonly"},(0,o.mdx)("inlineCode",{parentName:"h3"},"keyofStringsOnly")),(0,o.mdx)("p",null,"If you are seeing the following error:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"\nType error: Type 'string | number' does not satisfy the constraint 'string'.\nType 'number' is not assignable to type 'string'. TS2344\n\n")),(0,o.mdx)("p",null,"Ensure that your tsconfig file does not include ",(0,o.mdx)("inlineCode",{parentName:"p"},'"keyofStringsOnly": true,'),"."),(0,o.mdx)("h3",{id:"config-objects"},"Config objects"),(0,o.mdx)("p",null,"The generic types for ",(0,o.mdx)("inlineCode",{parentName:"p"},"MachineConfig<TContext, any, TEvent>")," are the same as those for ",(0,o.mdx)("inlineCode",{parentName:"p"},"createMachine<TContext, TEvent>"),", which is useful when you are defining a machine config object ",(0,o.mdx)("em",{parentName:"p"},"outside")," of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"createMachine(...)")," function, and helps prevent ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/statelyai/xstate/issues/310"},"inference errors"),":"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { MachineConfig } from 'xstate';\n\nconst myMachineConfig: MachineConfig<TContext, any, TEvent> = {\n  id: 'controller',\n  initial: 'stopped',\n  states: {\n    stopped: {\n      /* ... */\n    },\n    started: {\n      /* ... */\n    },\n  },\n  // ...\n};\n")))}m.isMDXComponent=!0}}]);