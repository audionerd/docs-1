"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[84198],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>l,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>d,withMDXComponents:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),m=function(e){return function(t){var n=d(t.components);return a.createElement(e,r({},t,{components:n}))}},d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=d(n),p=o,h=m["".concat(s,".").concat(p)]||m[p]||u[p]||r;return n?a.createElement(h,i(i({ref:t},l),{},{components:n})):a.createElement(h,i({ref:t},l))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},37937:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=n(87462),o=(n(67294),n(3905));n(50941);const r={title:"Actors"},s=void 0,i={unversionedId:"actors",id:"actors",title:"Actors",description:"When you run a state machine, it becomes an actor: a running process that can receive events, send events and change its behavior based on the events it receives, which can cause effects outside of the actor.",source:"@site/docs/actors.mdx",sourceDirName:".",slug:"/actors",permalink:"/docs/actors",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/docs/actors.mdx",tags:[],version:"current",frontMatter:{title:"Actors"},sidebar:"docs",previous:{title:"Actors ",permalink:"/docs/category/actors"},next:{title:"Invoke",permalink:"/docs/invoke"}},c={},l=[{value:"Using actors in Stately Studio",id:"using-actors-in-stately-studio",level:2},{value:"Actor model",id:"actor-model",level:2},{value:"Creating actor logic",id:"creating-actor-logic",level:2},{value:"Creating actors",id:"creating-actors",level:2},{value:"Invoking and spawning actors",id:"invoking-and-spawning-actors",level:3},{value:"Actor snapshots",id:"actor-snapshots",level:2},{value:"State machine actor logic",id:"state-machine-actor-logic",level:2},{value:"Promise actor logic",id:"promise-actor-logic",level:2},{value:"Transition function actors",id:"transition-function-actors",level:2},{value:"Observable actors",id:"observable-actors",level:2},{value:"Event observable actors",id:"event-observable-actors",level:2},{value:"Callback actors",id:"callback-actors",level:2},{value:"Higher-level actor logic",id:"higher-level-actor-logic",level:2},{value:"Custom actors",id:"custom-actors",level:2},{value:"Empty actors",id:"empty-actors",level:2},{value:"TypeScript",id:"typescript",level:2},{value:"Cheatsheet",id:"cheatsheet",level:2}],m={toc:l};function d(e){let{components:t,...n}=e;return(0,o.mdx)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"When you run a state machine, it becomes an actor: a running process that can receive events, send events and change its behavior based on the events it receives, which can cause effects outside of the actor."),(0,o.mdx)("p",null,"In state machines, actors can be ",(0,o.mdx)("strong",{parentName:"p"},"invoked")," or ",(0,o.mdx)("strong",{parentName:"p"},"spawned"),". These are essentially the same, with the only difference being how the actor\u2019s lifecycle is controlled."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"An ",(0,o.mdx)("strong",{parentName:"li"},"invoked actor")," is started when its parent machine enters the ",(0,o.mdx)("a",{parentName:"li",href:"/docs/states"},"state")," it is invoked in, and stopped when that state is exited."),(0,o.mdx)("li",{parentName:"ul"},"A ",(0,o.mdx)("strong",{parentName:"li"},"spawned actor")," is started in a ",(0,o.mdx)("a",{parentName:"li",href:"/docs/transitions"},"transition")," and stopped either with a ",(0,o.mdx)("a",{parentName:"li",href:"/docs/actions#stop-action"},(0,o.mdx)("inlineCode",{parentName:"a"},"stop(...)")," action")," or when its parent machine is stopped.")),(0,o.mdx)("admonition",{type:"tip"},(0,o.mdx)("p",{parentName:"admonition"},"Watch our ",(0,o.mdx)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=TRMS8NYKWnA&list=PLvWgkXBB3dd4I_l-djWVU2UGPyBgKfnTQ&index=9"},"\u201cWhat are invoked actors?\u201d video on YouTube")," (1m57s).")),(0,o.mdx)("h2",{id:"using-actors-in-stately-studio"},"Using actors in Stately Studio"),(0,o.mdx)("p",null,(0,o.mdx)("a",{parentName:"p",href:"/docs/invoke#using-invoked-actors-in-stately-studio"},"Read about using invoked actors in Stately Studio"),"."),(0,o.mdx)("h2",{id:"actor-model"},"Actor model"),(0,o.mdx)("p",null,"In the actor model, actors are objects that can communicate with each other. They are independent \u201clive\u201d entities that communicate via asynchronous message passing. In XState, these messages are referred to as ",(0,o.mdx)("em",{parentName:"p"},(0,o.mdx)("a",{parentName:"em",href:"/docs/transitions"},"events")),"."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"An actor has its own internal, encapsulated state that can only be updated by the actor itself. An actor may choose to update its internal state in response to a message it receives, but it cannot be updated by any other entity."),(0,o.mdx)("li",{parentName:"ul"},"Actors communicate with other actors by sending and receiving events asynchronously."),(0,o.mdx)("li",{parentName:"ul"},"Actors process one message at a time. They have an internal \u201cmailbox\u201d that acts like an event queue, processing events one at a time."),(0,o.mdx)("li",{parentName:"ul"},"Internal actor state is not shared between actors. The only way for an actor to share any part of its internal state is by:",(0,o.mdx)("ul",{parentName:"li"},(0,o.mdx)("li",{parentName:"ul"},"Sending events to other actors"),(0,o.mdx)("li",{parentName:"ul"},"Or emitting snapshots, which can be considered implicit events sent to subscribers."))),(0,o.mdx)("li",{parentName:"ul"},"Actors can create (spawn/invoke) new actors.")),(0,o.mdx)("h2",{id:"creating-actor-logic"},"Creating actor logic"),(0,o.mdx)("p",null,"Actor logic is the actor\u2019s logical \u201cmodel\u201d (brain, blueprint, DNA, etc.) It describes how the actor should change behavior when receiving an event. You can create actor logic using ",(0,o.mdx)("strong",{parentName:"p"},"actor logic creators"),". The types of actor logic you can create from XState are:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/cheatsheet#creating-a-state-machine"},"State machine logic (",(0,o.mdx)("inlineCode",{parentName:"a"},"createMachine(...)"),")")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/cheatsheet#creating-promise-logic"},"Promise logic (",(0,o.mdx)("inlineCode",{parentName:"a"},"fromPromise(...)"),")")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/cheatsheet#creating-promise-logic"},"Transition logic (",(0,o.mdx)("inlineCode",{parentName:"a"},"fromTransition(...)"),")")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/cheatsheet#creating-observable-logic"},"Observable logic (",(0,o.mdx)("inlineCode",{parentName:"a"},"fromObservable(...)"),")")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/migration#use-actor-logic-creators-for-invokesrc-instead-of-functions"},"Event observable logic (",(0,o.mdx)("inlineCode",{parentName:"a"},"fromEventObservable(...)"),")")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/cheatsheet#creating-callback-logic"},"Callback logic (",(0,o.mdx)("inlineCode",{parentName:"a"},"fromCallback(...)"),")"))),(0,o.mdx)("p",null,"In XState, actor logic is defined by an object containing methods like ",(0,o.mdx)("inlineCode",{parentName:"p"},".transition(...)"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},".getInitialState()"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},".getSnapshot()"),", and more. This object tells an interpreter how to update an actor\u2019s internal state when it receives an event and which effects to execute (if any)."),(0,o.mdx)("h2",{id:"creating-actors"},"Creating actors"),(0,o.mdx)("p",null,"You can create an actor, which is a \u201clive\u201d instance of some actor logic, via ",(0,o.mdx)("inlineCode",{parentName:"p"},"createActor(actorLogic, options?)"),". The ",(0,o.mdx)("inlineCode",{parentName:"p"},"createActor(...)")," function takes the following arguments:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"actorLogic"),": the ",(0,o.mdx)("a",{parentName:"li",href:"/docs/actors#creating-actor-logic"},"actor logic")," to create an actor from"),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"options")," (optional): actor options")),(0,o.mdx)("p",null,"When you create an actor from actor logic via ",(0,o.mdx)("inlineCode",{parentName:"p"},"createActor(actorLogic)"),", you implicitly create an ",(0,o.mdx)("a",{parentName:"p",href:"/docs/system"},"actor system")," where the created actor is the root actor. Any actors spawned from this root actor and its descendants are part of that actor system. The actor must be started by calling ",(0,o.mdx)("inlineCode",{parentName:"p"},"actor.start()"),", which will also start the actor system:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createActor } from 'xstate';\nimport { someActorLogic } from './someActorLogic.ts';\n\nconst actor = createActor(someActorLogic);\n\nactor.subscribe((snapshot) => {\n  console.log(snapshot);\n});\n\nactor.start();\n\n// Now the actor can receive events\nactor.send({ type: 'someEvent' });\n")),(0,o.mdx)("p",null,"You can stop root actors by calling ",(0,o.mdx)("inlineCode",{parentName:"p"},"actor.stop()"),", which will also stop the actor system and all actors in that system:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"// Stops the root actor, actor system, and actors in the system\nactor.stop();\n")),(0,o.mdx)("h3",{id:"invoking-and-spawning-actors"},"Invoking and spawning actors"),(0,o.mdx)("p",null,"An invoked actor represents a state-based actor, so it is stopped when the invoking state is exited. Invoked actors are used for a finite/known number of actors."),(0,o.mdx)("p",null,"A spawned actor represents multiple entities that can be started at any time and stopped at any time. Spawed actors are action-based and used for a dynamic or unknown number of actors."),(0,o.mdx)("p",null,"An example of the difference between invoking and spawning actors could occur in a todo app. When loading todos, a ",(0,o.mdx)("inlineCode",{parentName:"p"},"loadTodos")," actor would be an invoked actor; it represents a single state-based task. In comparison, each of the todos can themselves be spawned actors, and there can be a dynamic number of these actors."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/invoke"},"Read more about invoking actors")),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("a",{parentName:"li",href:"/docs/spawn"},"Read more about spawning actors"))),(0,o.mdx)("h2",{id:"actor-snapshots"},"Actor snapshots"),(0,o.mdx)("p",null,"When an actor receives an event, its internal state may change. An actor may emit a ",(0,o.mdx)("strong",{parentName:"p"},"snapshot")," when a state transition occurs. You can read an actor\u2019s snapshot synchronously via ",(0,o.mdx)("inlineCode",{parentName:"p"},"actor.getSnapshot()"),"."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { fromPromise, createActor } from 'xstate';\n\nasync function fetchCount() {\n  return Promise.resolve(42);\n}\n\nconst countLogic = fromPromise(async () => {\n  const count = await fetchCount();\n\n  return count;\n});\n\nconst countActor = createActor(countLogic);\n\ncountActor.start();\n\ncountActor.getSnapshot(); // logs undefined\n\n// After the promise resolves...\ncountActor.getSnapshot();\n// => {\n//   output: 42,\n//   status: 'done',\n//   ...\n// }\n")),(0,o.mdx)("p",null,"You can subscribe to an actor\u2019s snapshot values via ",(0,o.mdx)("inlineCode",{parentName:"p"},"actor.subscribe(observer)"),". The observer will receive the actor\u2019s snapshot value when it is emitted. The observer can be:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"A plain function that receives the latest snapshot, or"),(0,o.mdx)("li",{parentName:"ul"},"An observer object whose ",(0,o.mdx)("inlineCode",{parentName:"li"},".next(snapshot)")," method receives the latest snapshot")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"// Observer as a plain function\nconst subscription = actor.subscribe((snapshot) => {\n  console.log(snapshot);\n});\n")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"// Observer as an object\nconst subscription = actor.subscribe({\n  next(snapshot) {\n    console.log(snapshot);\n  },\n  error(err) {\n    // ...\n  },\n  complete() {\n    // ...\n  },\n});\n")),(0,o.mdx)("p",null,"The return value of ",(0,o.mdx)("inlineCode",{parentName:"p"},"actor.subscribe(observer)")," is a subscription object that has an ",(0,o.mdx)("inlineCode",{parentName:"p"},".unsubscribe()")," method. You can call ",(0,o.mdx)("inlineCode",{parentName:"p"},"subscription.unsubscribe()")," to unsubscribe the observer:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const subscription = actor.subscribe((snapshot) => {\n  /* ... */\n});\n\n// Unsubscribe the observer\nsubscription.unsubscribe();\n")),(0,o.mdx)("p",null,"When the actor is stopped, all of its observers will automatically be unsubscribed."),(0,o.mdx)("p",null,"You can initialize actor logic at a specific persisted internal state by passing the state in the second ",(0,o.mdx)("inlineCode",{parentName:"p"},"options")," argument of ",(0,o.mdx)("inlineCode",{parentName:"p"},"createActor(logic, options)"),". If the state is compatible with the actor logic, this will create an actor that will be started at that persisted state:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const persistedState = JSON.parse(localStorage.getItem('some-persisted-state'));\n\nconst actor = createActor(someLogic, {\n  // highlight-start\n  state: persistedState,\n  // highlight-end\n});\n\nactor.subscribe(() => {\n  localStorage.setItem(\n    'some-persisted-state',\n    JSON.stringify(actor.getPersistedState()),\n  );\n});\n\n// Actor will start at persisted state\nactor.start();\n")),(0,o.mdx)("p",null,"See ",(0,o.mdx)("a",{parentName:"p",href:"/docs/persistence"},"persistence")," for more details."),(0,o.mdx)("p",null,"You can wait for an actor\u2019s snapshot to satisfy a predicate using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"waitFor(actor, predicate, options?)")," helper function. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"waitFor(...)")," function returns a promise that is:"),(0,o.mdx)("p",null,"You can wait for an actor\u2019s snapshot to satisfy a predicate using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"waitFor(actor, predicate, options?)")," helper function. The ",(0,o.mdx)("inlineCode",{parentName:"p"},"waitFor(...)")," function returns a promise that is:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Resolved when the emitted snapshot satisfies the ",(0,o.mdx)("inlineCode",{parentName:"li"},"predicate")," function"),(0,o.mdx)("li",{parentName:"ul"},"Resolved immediately if the current snapshot already satisfies the ",(0,o.mdx)("inlineCode",{parentName:"li"},"predicate")," function"),(0,o.mdx)("li",{parentName:"ul"},"Rejected if an error is thrown or the ",(0,o.mdx)("inlineCode",{parentName:"li"},"options.timeout")," value is elapsed.")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { waitFor } from 'xstate';\nimport { countActor } from './countActor.ts';\n\nconst snapshot = await waitFor(\n  countActor,\n  (snapshot) => {\n    return snapshot.context.count >= 100;\n  },\n  {\n    timeout: 10_000, // 10 seconds (10,000 milliseconds)\n  },\n);\n\nconsole.log(snapshot.output);\n// => 100\n")),(0,o.mdx)("h2",{id:"state-machine-actor-logic"},"State machine actor logic"),(0,o.mdx)("p",null,"You can describe actor logic as a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/machines"},"state machine"),". Actors created from state machine actor logic can:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Receive events"),(0,o.mdx)("li",{parentName:"ul"},"Send events to other actors"),(0,o.mdx)("li",{parentName:"ul"},"Invoke/spawn child actors"),(0,o.mdx)("li",{parentName:"ul"},"Emit snapshots of its state"),(0,o.mdx)("li",{parentName:"ul"},"Output a value when the machine reaches its top-level final state")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const toggleMachine = createMachine({\n  id: 'toggle',\n  initial: 'inactive',\n  states: {\n    inactive: {},\n    active: {},\n  },\n});\n\nconst toggleActor = createActor(toggleMachine);\n\ntoggleActor.subscribe((snapshot) => {\n  // snapshot is the machine's state\n  console.log('state', snapshot.value);\n  console.log('context', snapshot.context);\n});\ntoggleActor.start();\n// Logs 'inactive'\ntoggleActor.send({ type: 'toggle' });\n// Logs 'active'\n")),(0,o.mdx)("h2",{id:"promise-actor-logic"},"Promise actor logic"),(0,o.mdx)("p",null,"Promise actor logic is described by an async process that resolves or rejects after some time. Actors created from promise logic (\u201cpromise actors\u201d) can:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Emit the resolved value of the promise"),(0,o.mdx)("li",{parentName:"ul"},"Output the resolved value of the promise")),(0,o.mdx)("p",null,"Sending events to promise actors will have no effect."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const promiseLogic = fromPromise(() => {\n  return fetch('https://example.com/...').then((data) => data.json());\n});\n\nconst promiseActor = createActor(promiseLogic);\npromiseActor.subscribe((snapshot) => {\n  console.log(snapshot);\n});\npromiseActor.start();\n// => {\n//   output: undefined,\n//   status: 'active'\n//   ...\n// }\n\n// After promise resolves\n// => {\n//   output: { ... },\n//   status: 'done',\n//   ...\n// }\n")),(0,o.mdx)("h2",{id:"transition-function-actors"},"Transition function actors"),(0,o.mdx)("p",null,"Transition actor logic is described by a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/migration#use-actor-logic-creators-for-invokesrc-instead-of-functions"},"transition function"),", similar to a ",(0,o.mdx)("a",{parentName:"p",href:"/docs/cheatsheet#creating-transition-logic"},"reducer"),". Transition functions take the current ",(0,o.mdx)("inlineCode",{parentName:"p"},"state")," and received ",(0,o.mdx)("inlineCode",{parentName:"p"},"event")," object as arguments, and return the next state. Actors created from transition logic (\u201ctransition actors\u201d) can:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Receive events"),(0,o.mdx)("li",{parentName:"ul"},"Emit snapshots of its state")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const transitionLogic = fromTransition(\n  (state, event) => {\n    if (event.type === 'increment') {\n      return {\n        ...state,\n        count: state.count + 1,\n      };\n    }\n    return state;\n  },\n  { count: 0 },\n);\n\nconst transitionActor = createActor(transitionLogic);\ntransitionActor.subscribe((snapshot) => {\n  console.log(snapshot);\n});\ntransitionActor.start();\n// => {\n//   status: 'active',\n//   context: { count: 0 },\n//   ...\n// }\n\ntransitionActor.send({ type: 'increment' });\n// => {\n//   status: 'active',\n//   context: { count: 1 },\n//   ...\n// }\n")),(0,o.mdx)("h2",{id:"observable-actors"},"Observable actors"),(0,o.mdx)("p",null,"Observable actor logic is described by an ",(0,o.mdx)("a",{parentName:"p",href:"/docs/cheatsheet#creating-observable-logic"},"observable stream of values"),". Actors created from observable logic (\u201cobservable actors\u201d) can:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Emit snapshots of its emitted value")),(0,o.mdx)("p",null,"Sending events to observable actors will have no effect."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const secondLogic = fromObservable(() => interval(1000));\n\nconst secondActor = createActor(secondLogic);\n\nsecondActor.subscribe((snapshot) => {\n  console.log(snapshot.context);\n});\n\nsecondActor.start();\n// At every second:\n// Logs 0\n// Logs 1\n// Logs 2\n// ...\n")),(0,o.mdx)("h2",{id:"event-observable-actors"},"Event observable actors"),(0,o.mdx)("p",null,"Event observable actor logic is described by an observable stream of ",(0,o.mdx)("a",{parentName:"p",href:"/docs/transitions#event-objects"},"event objects"),". Actors created from event observable logic (\u201cevent observable actors\u201d) can:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Implicitly send events to its parent actor"),(0,o.mdx)("li",{parentName:"ul"},"Emit snapshots of its emitted event objects")),(0,o.mdx)("p",null,"Sending events to event observable actors will have no effect."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const mouseClickLogic = fromEventObservable(() =>\n  fromEventPattern(document.body, 'click'),\n);\n\nconst canvasMachine = createMachine({\n  invoke: {\n    // Will send mouse click events to the canvas actor\n    src: mouseClickLogic,\n  },\n});\n\nconst canvasActor = createActor(canvasMachine);\ncanvasActor.start();\n")),(0,o.mdx)("h2",{id:"callback-actors"},"Callback actors"),(0,o.mdx)("p",null,"Callback actor logic is described by a callback function that receives a single object argument that includes a ",(0,o.mdx)("inlineCode",{parentName:"p"},"sendBack(event)")," function and a ",(0,o.mdx)("inlineCode",{parentName:"p"},"receive(event => ...)")," function. Actors created from callback logic (\u201ccallback actors\u201d) can:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Receive events via the ",(0,o.mdx)("inlineCode",{parentName:"li"},"receive")," function"),(0,o.mdx)("li",{parentName:"ul"},"Send events to the parent actor via the ",(0,o.mdx)("inlineCode",{parentName:"li"},"sendBack")," function")),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const callbackLogic = fromCallback(({ sendBack, receive }) => {\n  let lockStatus = 'unlocked';\n\n  const handler = (event) => {\n    if (lockStatus === 'locked') {\n      return;\n    }\n    sendBack(event);\n  };\n\n  receive((event) => {\n    if (event.type === 'lock') {\n      lockStatus = 'locked';\n    } else if (event.type === 'unlock') {\n      lockStatus = 'unlocked';\n    }\n  });\n\n  document.body.addEventListener('click', handler);\n\n  return () => {\n    document.body.removeEventListener('click', handler);\n  };\n});\n")),(0,o.mdx)("p",null,"Callback actors are a bit different from other actors in that they do not do the following:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Do not work with ",(0,o.mdx)("inlineCode",{parentName:"li"},"onDone")," or ",(0,o.mdx)("inlineCode",{parentName:"li"},"onError")),(0,o.mdx)("li",{parentName:"ul"},"Do not produce a snapshot using ",(0,o.mdx)("inlineCode",{parentName:"li"},".getSnapshot()")),(0,o.mdx)("li",{parentName:"ul"},"Do not emit values when used with ",(0,o.mdx)("inlineCode",{parentName:"li"},".subscribe()")),(0,o.mdx)("li",{parentName:"ul"},"Can not be stopped with ",(0,o.mdx)("inlineCode",{parentName:"li"},".stop()"))),(0,o.mdx)("h2",{id:"higher-level-actor-logic"},"Higher-level actor logic"),(0,o.mdx)("p",null,"Higher-level actor logic enhances existing actor logic with additional functionality. For example, you can create actor logic that logs or persists actor state:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"function withLogging(actorLogic) {\n  const enhancedLogic = {\n    ...actorLogic,\n    transition: (state, event, actorCtx) => {\n      console.log('State:', state);\n      return actorLogic.transition(state, event, actorCtx);\n    },\n  };\n\n  return enhancedLogic;\n}\n\nconst loggingToggleLogic = withLogging(toggleLogic);\n")),(0,o.mdx)("h2",{id:"custom-actors"},"Custom actors"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Coming soon")),(0,o.mdx)("h2",{id:"empty-actors"},"Empty actors"),(0,o.mdx)("p",null,"Actor that does nothing and only has a single emitted snapshot: ",(0,o.mdx)("inlineCode",{parentName:"p"},"undefined")),(0,o.mdx)("p",null,"In XState, an empty actor is an actor that does nothing and only has a single emitted snapshot: ",(0,o.mdx)("inlineCode",{parentName:"p"},"undefined"),"."),(0,o.mdx)("p",null,"This is useful for testing, such as stubbing out an actor that is not yet implemented. It can also be useful in framework integrations, such as ",(0,o.mdx)("inlineCode",{parentName:"p"},"@xstate/react"),", where an actor may not be available yet:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createEmptyActor, AnyActorRef } from 'xstate';\nimport { useSelector } from '@xstate/react';\nconst emptyActor = createEmptyActor();\n\nfunction Component(props: { actor?: AnyActorRef }) {\n  const data = useSelector(\n    props.actor ?? emptyActor,\n    (snapshot) => snapshot.context.data,\n  );\n\n  // data is `undefined` if `props.actor` is undefined\n  // Otherwise, it is the data from the actor\n\n  // ...\n}\n")),(0,o.mdx)("h2",{id:"typescript"},"TypeScript"),(0,o.mdx)("p",null,"You can strongly type the ",(0,o.mdx)("inlineCode",{parentName:"p"},"actors")," of your machine in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"types.actors")," property of the machine config."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},"const fetcher = fromPromise(\n  async ({ input }: { input: { userId: string } }) => {\n    const user = await fetchUser(input.userId);\n\n    return user;\n  },\n);\n\nconst machine = createMachine({\n  types: {} as {\n    // highlight-start\n    actors: {\n      src: 'fetchData'; // src name (inline behaviors ideally inferred)\n      id: 'fetch1' | 'fetch2'; // possible ids (optional)\n      logic: typeof fetcher;\n    };\n    // highlight-end\n  },\n  invoke: {\n    src: 'fetchData', // strongly typed\n    id: 'fetch2', // strongly typed\n    onDone: {\n      actions: ({ event }) => {\n        event.output; // strongly typed as { result: string }\n      },\n    },\n    input: { userId: '42' }, // strongly typed\n  },\n});\n")),(0,o.mdx)("h2",{id:"cheatsheet"},"Cheatsheet"),(0,o.mdx)("p",null,(0,o.mdx)("em",{parentName:"p"},"Coming soon")))}d.isMDXComponent=!0}}]);