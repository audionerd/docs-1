"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[92769],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>d,MDXProvider:()=>p,mdx:()=>h,useMDXComponents:()=>u,withMDXComponents:()=>m});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var d=n.createContext({}),m=function(e){return function(t){var a=u(t.components);return n.createElement(e,r({},t,{components:a}))}},u=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=u(a),p=o,g=m["".concat(s,".").concat(p)]||m[p]||c[p]||r;return a?n.createElement(g,l(l({ref:t},d),{},{components:a})):n.createElement(g,l({ref:t},d))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=g;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},57942:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var n=a(87462),o=(a(67294),a(3905));const r={title:"How to tell a bad boolean from a good boolean",description:"TL;DR: Bad booleans represent state. Good booleans are derived from state",tags:["tutorial"],authors:["matt"],category:"entry",image:"/blog/2020-05-27-state-management-bad-bolean-good-boolean.png",slug:"2020-05-27-state-management-bad-bolean-good-boolean",date:new Date("2020-05-27T00:00:00.000Z")},s=void 0,l={permalink:"/statelyai-docs/blog/2020-05-27-state-management-bad-bolean-good-boolean",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2020-05-27-state-management-bad-bolean-good-boolean/index.mdx",source:"@site/blog/2020-05-27-state-management-bad-bolean-good-boolean/index.mdx",title:"How to tell a bad boolean from a good boolean",description:"TL;DR: Bad booleans represent state. Good booleans are derived from state",date:"2020-05-27T00:00:00.000Z",formattedDate:"May 27, 2020",tags:[{label:"tutorial",permalink:"/statelyai-docs/blog/tags/tutorial"}],readingTime:3.015,hasTruncateMarker:!0,authors:[{name:"Matt Pocock",title:"Stately Team",url:"https://github.com/mattpocock",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/matt.png",key:"matt"}],frontMatter:{title:"How to tell a bad boolean from a good boolean",description:"TL;DR: Bad booleans represent state. Good booleans are derived from state",tags:["tutorial"],authors:["matt"],category:"entry",image:"/blog/2020-05-27-state-management-bad-bolean-good-boolean.png",slug:"2020-05-27-state-management-bad-bolean-good-boolean",date:"2020-05-27T00:00:00.000Z"},prevItem:{title:"State machines: How to stop making Horcruxes in your code",permalink:"/statelyai-docs/blog/2020-07-27-state-machines-how-to-stop-making-horcruxes-in-your-code"},nextItem:{title:"Redux is half of a pattern (2/2)",permalink:"/statelyai-docs/blog/2020-05-22-redux-is-half-a-pattern-2-2"}},i={authorsImageUrls:[void 0]},d=[{value:"Implicit states",id:"implicit-states",level:2},{value:"Making states explicit",id:"making-states-explicit",level:2},{value:"Making good booleans",id:"making-good-booleans",level:2},{value:"Addendum: Enums in Javascript",id:"addendum-enums-in-javascript",level:2}],m={toc:d};function u(e){let{components:t,...a}=e;return(0,o.mdx)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"TL;DR"),": Bad booleans represent state. Good booleans are derived from state."),(0,o.mdx)("p",null,"When you\u2019re managing state in your app, it\u2019s easy to fall prey to bad booleans. Bad booleans look like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"let isLoading = true;\nlet isComplete = false;\nlet hasErrored = false;\n")),(0,o.mdx)("p",null,"On the surface, this looks like good code. It appears as though you\u2019ve represented three separate states with proper boolean names. In the \u2018model\u2019 you\u2019ve pictured for your state, only one of these states can be true at any one time."),(0,o.mdx)("p",null,"In a fetch request, you might model the state like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'const makeFetch = async () => {\n  isLoading = true;\n  try {\n    await fetch("/users");\n\n    isComplete = true;\n  } catch (e) {\n    hasErrored = true;\n  }\n  isLoading = false;\n};\n')),(0,o.mdx)("p",null,"Again, this looks nice. We\u2019re orchestrating our booleans as we move through the async request."),(0,o.mdx)("p",null,"But there\u2019s a bug here. What happens if we make the fetch, it succeeds, and we make the fetch again? We\u2019ll end up with:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"let isLoading = true;\nlet isComplete = true;\nlet hasErrored = false;\n")),(0,o.mdx)("h2",{id:"implicit-states"},"Implicit states"),(0,o.mdx)("p",null,"You probably hadn\u2019t considered this when you made your initial model. You may have frontend components which are checking for ",(0,o.mdx)("inlineCode",{parentName:"p"},"isComplete === ")," true or ",(0,o.mdx)("inlineCode",{parentName:"p"},"isLoading === true"),". You might end up with a loading spinner and the previous data showing at the same time."),(0,o.mdx)("p",null,"How is this possible? Well, you\u2019ve created some implicit states. Let\u2019s imagine you considered 3 states as ones you actually wanted to handle:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("inlineCode",{parentName:"li"},"loading"),": Loading the data"),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("inlineCode",{parentName:"li"},"complete"),": Showing the data"),(0,o.mdx)("li",{parentName:"ol"},(0,o.mdx)("inlineCode",{parentName:"li"},"errored"),": Erroring if the data doesn't turn up")),(0,o.mdx)("p",null,"Well, you\u2019ve actually allowed 8 states! That\u2019s 2 for the first boolean, times 2 for the second, times 2 for the third."),(0,o.mdx)("p",null,"This is what's known as boolean explosion - I learned about this from ",(0,o.mdx)("a",{parentName:"p",href:"https://egghead.io/lessons/javascript-eliminate-boolean-explosion-by-enumerating-states"},"Kyle Shevlin's egghead course"),"."),(0,o.mdx)("h2",{id:"making-states-explicit"},"Making states explicit"),(0,o.mdx)("p",null,"How do you get around this? Instead of a system with 8 possible values, we need a system with three possible values. We can do this in Typescript with an enum."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'type Status = "loading" | "complete" | "errored";\n\nlet status: Status = "loading";\n')),(0,o.mdx)("p",null,"We\u2019d implement this in a fetch like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const makeFetch = async () => {\n  status = "loading";\n  try {\n    await fetch("/users");\n\n    status = "complete";\n  } catch (e) {\n    status = "errored";\n  }\n};\n')),(0,o.mdx)("p",null,"It\u2019s now impossible to be in the 'loading' and 'complete' state at once - we\u2019ve fixed our bug. We\u2019ve turned our bad booleans into a good enum."),(0,o.mdx)("h2",{id:"making-good-booleans"},"Making good booleans"),(0,o.mdx)("p",null,"But not all booleans are bad. Many popular libraries, such as ",(0,o.mdx)("em",{parentName:"p"},"react-query"),", ",(0,o.mdx)("em",{parentName:"p"},"apollo")," and ",(0,o.mdx)("em",{parentName:"p"},"urql")," use booleans in their state. An example implementation:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},"const [result] = useQuery();\n\nif (result.isLoading) {\n  return <div>Loading...</div>;\n}\n")),(0,o.mdx)("p",null,"The reason these are good booleans is that their underlying mechanism is based on an enum. Bad booleans represent state. Good booleans are derived from state:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-js"},'let status: Status = "loading";\n\n// Derived from the status above\nlet isLoading = status === "loading";\n')),(0,o.mdx)("p",null,"You can safely use this ",(0,o.mdx)("inlineCode",{parentName:"p"},"isLoading")," to display your loading spinner, happy in the knowledge that you've removed all impossible states."),(0,o.mdx)("h2",{id:"addendum-enums-in-javascript"},"Addendum: Enums in Javascript"),(0,o.mdx)("p",null,"We can represent a state enum in Javascript as well. While the above code will work without typings, you can represent enums as an object type."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const statusEnum = {\n  loading: "loading",\n  complete: "complete",\n  errored: "errored",\n};\n\nlet status = statusEnum.loading;\n\nconst makeFetch = async () => {\n  status = statusEnum.loading;\n  try {\n    await fetch("/users");\n\n    status = statusEnum.complete;\n  } catch (e) {\n    status = statusEnum.errored;\n  }\n};\n')))}u.isMDXComponent=!0}}]);