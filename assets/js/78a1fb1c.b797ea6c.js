"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[41565],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>c,MDXProvider:()=>u,mdx:()=>g,useMDXComponents:()=>d,withMDXComponents:()=>p});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},r.apply(this,arguments)}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),p=function(e){return function(t){var a=d(t.components);return n.createElement(e,r({},t,{components:a}))}},d=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=d(a),u=o,h=p["".concat(l,".").concat(u)]||p[u]||m[u]||r;return a?n.createElement(h,s(s({ref:t},c),{},{components:a})):n.createElement(h,s({ref:t},c))}));function g(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,l=new Array(r);l[0]=h;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},63607:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(87462),o=(a(67294),a(3905));const r={title:"How to manage global state with XState and React",description:"Everything you need to know to manage global state with XState and React.",authors:["matt"],date:new Date("2021-05-27T00:00:00.000Z"),tags:["xstate","react","redux","webdev"],category:"entry",image:"/blog/2021-05-27-global-state-xstate-react.png",slug:"2021-05-27-global-state-xstate-react"},l=void 0,s={permalink:"/blog/2021-05-27-global-state-xstate-react",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2021-05-27-global-state-xstate-react/index.mdx",source:"@site/blog/2021-05-27-global-state-xstate-react/index.mdx",title:"How to manage global state with XState and React",description:"Everything you need to know to manage global state with XState and React.",date:"2021-05-27T00:00:00.000Z",formattedDate:"May 27, 2021",tags:[{label:"xstate",permalink:"/blog/tags/xstate"},{label:"react",permalink:"/blog/tags/react"},{label:"redux",permalink:"/blog/tags/redux"},{label:"webdev",permalink:"/blog/tags/webdev"}],readingTime:4.025,hasTruncateMarker:!0,authors:[{name:"Matt Pocock",title:"Stately Team",url:"https://github.com/mattpocock",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/matt.png",key:"matt"}],frontMatter:{title:"How to manage global state with XState and React",description:"Everything you need to know to manage global state with XState and React.",authors:["matt"],date:"2021-05-27T00:00:00.000Z",tags:["xstate","react","redux","webdev"],category:"entry",image:"/blog/2021-05-27-global-state-xstate-react.png",slug:"2021-05-27-global-state-xstate-react"},prevItem:{title:"useState vs useReducer vs XState - Part 1: Modals",permalink:"/blog/2021-07-28-usestate-vs-usereducer-vs-xstate-part-1-modals"},nextItem:{title:"Why I love invoked callbacks",permalink:"/blog/2021-05-13-why-i-love-invoked-callbacks"}},i={authorsImageUrls:[void 0]},c=[{value:"A globally available store",id:"a-globally-available-store",level:2},{value:"Utilising context",id:"utilising-context",level:2},{value:"Improving Performance",id:"improving-performance",level:2},{value:"Deviations from Flux",id:"deviations-from-flux",level:2},{value:"Summary",id:"summary",level:2}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,o.mdx)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"Many React applications follow the Flux architecture popularised by ",(0,o.mdx)("a",{parentName:"p",href:"https://redux.js.org/"},"Redux"),". This setup can be characterised by a few key ideas:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"It uses a single object at the top of your app which stores all application state, often called the ",(0,o.mdx)("strong",{parentName:"li"},"store"),"."),(0,o.mdx)("li",{parentName:"ol"},"It provides a single ",(0,o.mdx)("inlineCode",{parentName:"li"},"dispatch")," function which can be used to send messages up to the store. Redux calls these ",(0,o.mdx)("inlineCode",{parentName:"li"},"action"),"s, but I'll be calling them ",(0,o.mdx)("inlineCode",{parentName:"li"},"events")," - as they're known in XState."),(0,o.mdx)("li",{parentName:"ol"},"How the store responds to these messages from the app are expressed in pure functions - most often in ",(0,o.mdx)("strong",{parentName:"li"},"reducers"),".")),(0,o.mdx)("p",null,"This article won't go into depth on whether the Flux architecture is a good idea. David Khourshid's article ",(0,o.mdx)("a",{parentName:"p",href:"https://dev.to/davidkpiano/redux-is-half-of-a-pattern-1-2-1hd7"},"Redux is half a pattern")," goes into great detail here. For the purposes of this article, we're going to assume that you like having a global store, and you want to replicate it in XState."),(0,o.mdx)("p",null,"There are many reasons for wanting to do so. XState is second-to-none when it comes to managing complex asynchronous behaviour and modelling difficult problems. Managing this in Redux apps usually involves middleware: either ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk"},"redux-thunk"),", ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/redux-loop/redux-loop"},"redux-loop")," or ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/redux-saga/redux-saga"},"redux-saga"),". Choosing XState gives you a first-class way to manage complexity."),(0,o.mdx)("h2",{id:"a-globally-available-store"},"A globally available store"),(0,o.mdx)("p",null,"To mimic Redux's globally-available store, we're going to use React context. React context can be a tricky tool to work with - if you pass in values which change too often, in can result in re-renders all the way down the tree. That means we need to pass in values which change as little as possible."),(0,o.mdx)("p",null,"Luckily, XState gives us a first-class way to do that."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'import React, { createContext } from "react";\nimport { useInterpret } from "@xstate/react";\nimport { authMachine } from "./authMachine";\nimport { ActorRefFrom } from "xstate";\n\ninterface GlobalStateContextType {\n  authService: ActorRefFrom<typeof authMachine>;\n}\n\nexport const GlobalStateContext = createContext(\n  // Typed this way to avoid TS errors,\n  // looks odd I know\n  {} as GlobalStateContextType\n);\n\nexport const GlobalStateProvider = (props) => {\n  const authService = useInterpret(authMachine);\n\n  return (\n    <GlobalStateContext.Provider value={{ authService }}>\n      {props.children}\n    </GlobalStateContext.Provider>\n  );\n};\n')),(0,o.mdx)("p",null,"Using ",(0,o.mdx)("inlineCode",{parentName:"p"},"useInterpret")," returns a ",(0,o.mdx)("inlineCode",{parentName:"p"},"service"),", which is a static reference to the running machine which can be subscribed to. This value never changes, so we don't need to worry about wasted re-renders."),(0,o.mdx)("h2",{id:"utilising-context"},"Utilising context"),(0,o.mdx)("p",null,"Further down the tree, you can subscribe to the service like this:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'import React, { useContext } from "react";\nimport { GlobalStateContext } from "./globalState";\nimport { useActor } from "@xstate/react";\n\nexport const SomeComponent = (props) => {\n  const globalServices = useContext(GlobalStateContext);\n  const [state] = useActor(globalServices.authService);\n\n  return state.matches("loggedIn") ? "Logged In" : "Logged Out";\n};\n')),(0,o.mdx)("p",null,"The ",(0,o.mdx)("inlineCode",{parentName:"p"},"useActor")," hook listens for whenever the service changes, and updates the ",(0,o.mdx)("inlineCode",{parentName:"p"},"state")," value."),(0,o.mdx)("h2",{id:"improving-performance"},"Improving Performance"),(0,o.mdx)("p",null,"There's an issue with the implementation above - this will update the component for any change to the service. Redux offers tools for deriving state using selectors - functions which restrict which parts of the state can result in components re-rendering."),(0,o.mdx)("p",null,"Luckily, XState provides that too."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'import React, { useContext } from "react";\nimport { GlobalStateContext } from "./globalState";\nimport { useSelector } from "@xstate/react";\n\nconst selector = (state) => {\n  return state.matches("loggedIn");\n};\n\nexport const SomeComponent = (props) => {\n  const globalServices = useContext(GlobalStateContext);\n  const isLoggedIn = useSelector(globalServices.authService, selector);\n\n  return isLoggedIn ? "Logged In" : "Logged Out";\n};\n')),(0,o.mdx)("p",null,"Now, this component will only re-render when ",(0,o.mdx)("inlineCode",{parentName:"p"},"state.matches('loggedIn')")," returns a different value. This is my recommended approach over ",(0,o.mdx)("inlineCode",{parentName:"p"},"useActor")," for when you want to optimise performance.\nDispatching events"),(0,o.mdx)("p",null,"For dispatching events to the global store, you can call a service's send function directly."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'import React, { useContext } from "react";\nimport { GlobalStateContext } from "./globalState";\n\nexport const SomeComponent = (props) => {\n  const globalServices = useContext(GlobalStateContext);\n\n  return (\n    <button onClick={() => globalServices.authService.send("LOG_OUT")}>\n      Log Out\n    </button>\n  );\n};\n')),(0,o.mdx)("p",null,"Note that you don't need to call useActor for this, it's available right on the context."),(0,o.mdx)("h2",{id:"deviations-from-flux"},"Deviations from Flux"),(0,o.mdx)("p",null,"Keen-eyed readers may spot that this implementation is slightly different from Flux. For instance - instead of a single global store, one might have several running machines at once: ",(0,o.mdx)("inlineCode",{parentName:"p"},"authService"),", ",(0,o.mdx)("inlineCode",{parentName:"p"},"dataCacheService"),", and ",(0,o.mdx)("inlineCode",{parentName:"p"},"globalTimeoutService"),". Each of them have their own ",(0,o.mdx)("inlineCode",{parentName:"p"},"send")," attributes, too - so you're not calling a global dispatch."),(0,o.mdx)("p",null,"These changes can be worked around. One could create a synthetic send inside the global store which called all the services' ",(0,o.mdx)("inlineCode",{parentName:"p"},"send")," function manually. But personally, I prefer knowing exactly which services my messages are being passed to, and it avoids having to keep events globally namespaced."),(0,o.mdx)("h2",{id:"summary"},"Summary"),(0,o.mdx)("p",null,"XState can work beautifully as a global store for a React application. It keeps application logic co-located, treats side effects as first-class citizens, and offers good performance with ",(0,o.mdx)("inlineCode",{parentName:"p"},"useSelector"),". You should choose this approach if you're keen on the Flux architecture but feel your app's logic is getting out of hand."))}d.isMDXComponent=!0}}]);