"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[75811],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>m,withMDXComponents:()=>d});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(){return r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},r.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),d=function(e){return function(n){var t=m(n.components);return a.createElement(e,r({},n,{components:t}))}},m=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=m(e.components);return a.createElement(c.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=m(t),p=o,u=d["".concat(i,".").concat(p)]||d[p]||h[p]||r;return t?a.createElement(u,s(s({ref:n},c),{},{components:t})):a.createElement(u,s({ref:n},c))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2506:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const r={title:"Should this be an action, or a service?",description:"Whether to use an action or a service in XState.",tags:["action","state machine","xstate","service"],authors:["matt"],image:"/blog/2021-04-30-should-this-be-an-action-or-a-service.png",slug:"2021-04-30-should-this-be-an-action-or-a-service",date:new Date("2021-04-30T00:00:00.000Z")},i=void 0,s={permalink:"/blog/2021-04-30-should-this-be-an-action-or-a-service",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2021-04-30-should-this-be-an-action-or-a-service/index.mdx",source:"@site/blog/2021-04-30-should-this-be-an-action-or-a-service/index.mdx",title:"Should this be an action, or a service?",description:"Whether to use an action or a service in XState.",date:"2021-04-30T00:00:00.000Z",formattedDate:"April 30, 2021",tags:[{label:"action",permalink:"/blog/tags/action"},{label:"state machine",permalink:"/blog/tags/state-machine"},{label:"xstate",permalink:"/blog/tags/xstate"},{label:"service",permalink:"/blog/tags/service"}],readingTime:4.885,hasTruncateMarker:!0,authors:[{name:"Matt Pocock",title:"Stately Team",url:"https://github.com/mattpocock",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/matt.png",key:"matt"}],frontMatter:{title:"Should this be an action, or a service?",description:"Whether to use an action or a service in XState.",tags:["action","state machine","xstate","service"],authors:["matt"],image:"/blog/2021-04-30-should-this-be-an-action-or-a-service.png",slug:"2021-04-30-should-this-be-an-action-or-a-service",date:"2021-04-30T00:00:00.000Z"},prevItem:{title:"Why I love invoked callbacks",permalink:"/blog/2021-05-13-why-i-love-invoked-callbacks"},nextItem:{title:"Should this be a state, or in context?",permalink:"/blog/2021-04-29-should-this-be-a-state-or-in-context"}},l={authorsImageUrls:[void 0]},c=[{value:"Actions",id:"actions",level:2},{value:"Services",id:"services",level:2},{value:"Guidelines",id:"guidelines",level:2}],d={toc:c};function m(e){let{components:n,...t}=e;return(0,o.mdx)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"XState offers several ways of orchestrating side effects. Since it\u2019s a statechart tool, ",(0,o.mdx)("a",{parentName:"p",href:"https://dev.to/mpocock1/usestate-vs-usereducer-vs-xstate-part-1-modals-569e"},"with significantly more power than a reducer"),", side effects are treated as a first-class concept."),(0,o.mdx)("p",null,"\u2018Side effects\u2019 as a concept spring from the idea of \u2018pure\u2019 functions. I.e. a function is at its best when it takes an input and returns an output. Pure functions don\u2019t tend to involve:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Waiting a set amount of time"),(0,o.mdx)("li",{parentName:"ul"},"Making an API call to an external service"),(0,o.mdx)("li",{parentName:"ul"},"Logging things to an external service")),(0,o.mdx)("p",null,"So we can think of all of the above as \u2018side effects\u2019 of our programme running. The name gives them a negative, medical, connotation - but really, they\u2019re the meat of your app. Apps that don\u2019t have side effects don\u2019t talk to anything external, don\u2019t worry about time, and don\u2019t react to unexpected errors."),(0,o.mdx)("h2",{id:"actions"},"Actions"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"\u201cThank u, next.\u201d - Ariana Grande")),(0,o.mdx)("p",null,"Side effects can be expressed in two ways in XState. First, as a fire-and-forget ",(0,o.mdx)("inlineCode",{parentName:"p"},"action"),". Let\u2019s imagine that when the user opens this modal, we want to report to a logging service that this happened."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const modalMachine = createMachine(\n  {\n    initial: "closed",\n    states: {\n      closed: {\n        on: {\n          OPEN: "open",\n        },\n      },\n      open: {\n        entry: ["reportThatUserOpenedTheModal"],\n        on: {\n          CLOSE: "closed",\n        },\n      },\n    },\n  },\n  {\n    actions: {\n      // Note that I\'m declaring the action name above, but implementing\n      // it here. This keeps the logic and implementation separate,\n      // which I like\n      reportThatUserOpenedTheModal: async () => {\n        await fetch("/external-service/user-opened-modal");\n      },\n    },\n  }\n);\n')),(0,o.mdx)("p",null,"Actions are fire-and-forget, which means you can fire them off without worrying about consequences. If the action I declared above errors, my state machine won\u2019t react - it\u2019s already forgotten about it."),(0,o.mdx)("p",null,"Actions represent a single point in time, like a dot on a graph. This means that you can place them very flexibly. Above, I\u2019ve placed them on the ",(0,o.mdx)("inlineCode",{parentName:"p"},"entry")," attribute of the state, meaning that action will be fired when we enter the state. I could also place them on the transition:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const modalMachine = createMachine(\n  {\n    initial: "closed",\n    states: {\n      closed: {\n        on: {\n          OPEN: {\n            actions: "reportThatUserOpenedTheModal",\n            target: "open",\n          },\n        },\n      },\n      open: {\n        on: {\n          CLOSE: "closed",\n        },\n      },\n    },\n  },\n  {\n    actions: {\n      reportThatUserOpenedTheModal: async () => {\n        // implementation\n      },\n    },\n  }\n);\n')),(0,o.mdx)("p",null,"This means that whenever ",(0,o.mdx)("inlineCode",{parentName:"p"},"OPEN")," is called from the ",(0,o.mdx)("inlineCode",{parentName:"p"},"closed")," state, that action will be fired. In this modal, we could also fire the action whenever the user leaves the ",(0,o.mdx)("inlineCode",{parentName:"p"},"closed")," state, since we know they\u2019ll be going to the ",(0,o.mdx)("inlineCode",{parentName:"p"},"open")," state."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const modalMachine = createMachine(\n  {\n    initial: "closed",\n    states: {\n      closed: {\n        on: {\n          OPEN: "open",\n        },\n        exit: ["reportThatUserOpenedTheModal"],\n      },\n      open: {\n        on: {\n          CLOSE: "closed",\n        },\n      },\n    },\n  },\n  {\n    actions: {\n      reportThatUserOpenedTheModal: async () => {\n        // implementation\n      },\n    },\n  }\n);\n')),(0,o.mdx)("p",null,"Actions are flexible precisely because we don\u2019t care about their outcome. We can hang them on the hooks our state machine gives us: transitions between states, exiting states and entering states."),(0,o.mdx)("h2",{id:"services"},"Services"),(0,o.mdx)("blockquote",null,(0,o.mdx)("p",{parentName:"blockquote"},"\u201cAnd I plan to be forgotten when I\u2019m gone\u2026\u201d - The Tallest Man on Earth")),(0,o.mdx)("p",null,"But actions have a specific limitation - they are designed to be forgotten. Let\u2019s imagine that you wanted to track whether the analytics call you made was successful, and only open the modal if it was. We\u2019ll add an ",(0,o.mdx)("inlineCode",{parentName:"p"},"opening")," state which handles that check."),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const modalMachine = createMachine({\n  initial: "closed",\n  states: {\n    closed: {\n      on: {\n        OPEN: "opening",\n      },\n    },\n    opening: {\n      entry: [\n        async () => {\n          await fetch("/external-service/user-opened-modal");\n\n          // OK, this was successful - how do I get to the open state?!\n        },\n      ],\n    },\n    open: {\n      on: {\n        CLOSE: "closed",\n      },\n    },\n  },\n});\n')),(0,o.mdx)("p",null,"This isn\u2019t possible in an action. We can\u2019t fire back an event to the machine, because it\u2019s already forgotten about us."),(0,o.mdx)("p",null,"When you care about the result of an action, put it in a service. This is how this would be expressed as a service:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre",className:"language-ts"},'const modalMachine = createMachine({\n  initial: "closed",\n  states: {\n    closed: {\n      on: {\n        OPEN: "opening",\n      },\n    },\n    opening: {\n      invoke: {\n        // This uses the invoked callback syntax - my favourite\n        // syntax for expressing services\n        src: () => async (send) => {\n          await fetch("/external-service/user-opened-modal");\n\n          send("OPENED_SUCCESSFULLY");\n        },\n        onError: {\n          target: "closed",\n        },\n      },\n      on: {\n        OPENED_SUCCESSFULLY: {\n          target: "open",\n        },\n      },\n    },\n    open: {\n      on: {\n        CLOSE: "closed",\n      },\n    },\n  },\n});\n')),(0,o.mdx)("p",null,"If actions are a dot on the graph, services represent a line - a continuous process which takes some amount of time. If the service errors, it\u2019ll trigger an event called ",(0,o.mdx)("inlineCode",{parentName:"p"},"error.platform.serviceName"),", which you can listen for with the ",(0,o.mdx)("inlineCode",{parentName:"p"},"onError")," attribute, as above."),(0,o.mdx)("p",null,"Crucially, they can also send events back to the machine, using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"send")," function above. Notice that we\u2019re both sending back the ",(0,o.mdx)("inlineCode",{parentName:"p"},"OPENED_SUCCESSFULLY")," event ",(0,o.mdx)("em",{parentName:"p"},"and")," listening to it in the ",(0,o.mdx)("inlineCode",{parentName:"p"},"on: {}")," attribute of the ",(0,o.mdx)("inlineCode",{parentName:"p"},"opening")," state."),(0,o.mdx)("p",null,"Services are less flexible than actions, because they demand more from you. You can\u2019t hang them on every hook your machine offers. They must be contained within one state, and they\u2019re cancelled when you leave that state. (Note: they can also be at the root of the machine definition, meaning they run for the lifetime of the machine.)"),(0,o.mdx)("h2",{id:"guidelines"},"Guidelines"),(0,o.mdx)("p",null,"Actions are the \u2018thank u, next\u2019 of the XState world. They represent points in time. Use them for fire-and-forget actions. Actions are great for:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"console.log")),(0,o.mdx)("li",{parentName:"ul"},"Showing ephemeral error or success messages (toasts)"),(0,o.mdx)("li",{parentName:"ul"},"Navigating between pages"),(0,o.mdx)("li",{parentName:"ul"},"Firing off events to external services or parents of your machine")),(0,o.mdx)("p",null,"Services are like a \u2018phase\u2019 your machine goes through. They represent a length of time. Use them for processes where you care about the outcome, or you want the process to run for a long time. Services are great for:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"API calls"),(0,o.mdx)("li",{parentName:"ul"},"Event listeners (",(0,o.mdx)("inlineCode",{parentName:"li"},"window.addEventListener"),")")))}m.isMDXComponent=!0}}]);