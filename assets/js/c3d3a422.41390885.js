"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[55308],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>v,mdx:()=>u,useMDXComponents:()=>p,withMDXComponents:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},o.apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),m=function(e){return function(t){var n=p(t.components);return r.createElement(e,o({},t,{components:n}))}},p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},v=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),v=a,d=m["".concat(s,".").concat(v)]||m[v]||b[v]||o;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},74972:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const o={title:"Observables",description:"Observables are streams of values emitted over time. Observables can be invoked, sending events to the parent machine."},s="Observables",i={unversionedId:"xstate/actors/observables",id:"version-4/xstate/actors/observables",title:"Observables",description:"Observables are streams of values emitted over time. Observables can be invoked, sending events to the parent machine.",source:"@site/versioned_docs/version-4/xstate/actors/observables.mdx",sourceDirName:"xstate/actors",slug:"/xstate/actors/observables",permalink:"/docs/xstate-v4/xstate/actors/observables",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/versioned_docs/version-4/xstate/actors/observables.mdx",tags:[],version:"4",frontMatter:{title:"Observables",description:"Observables are streams of values emitted over time. Observables can be invoked, sending events to the parent machine."},sidebar:"tutorialSidebar",previous:{title:"Machines",permalink:"/docs/xstate-v4/xstate/actors/machines"},next:{title:"Parent to child communication",permalink:"/docs/xstate-v4/xstate/actors/parent-child-communication"}},l={},c=[{value:"Hot observables",id:"hot-observables",level:3}],m={toc:c};function p(e){let{components:t,...n}=e;return(0,a.mdx)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"observables"},"Observables"),(0,a.mdx)("p",null,(0,a.mdx)("a",{parentName:"p",href:"https://github.com/tc39/proposal-observable"},"Observables")," are streams of values emitted over time. They could be considered an array or collection whose values are emitted asynchronously instead of all at once. There are many implementations of observables in JavaScript; the most popular one is ",(0,a.mdx)("a",{parentName:"p",href:"https://github.com/ReactiveX/rxjs"},"RxJS"),"."),(0,a.mdx)("p",null,"Observables can be invoked, sending events to the parent machine. An observable invocation is a function that takes ",(0,a.mdx)("inlineCode",{parentName:"p"},"context")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"event")," as arguments and returns an observable stream of events. The observable is unsubscribed when the state on which the observable is invoked is exited."),(0,a.mdx)("p",null,"In the example below, the ",(0,a.mdx)("inlineCode",{parentName:"p"},"intervalMachine")," will receive the events from ",(0,a.mdx)("inlineCode",{parentName:"p"},"interval(...)")," mapped to event objects until the observable is \u201ccompleted\u201d when it\u2019s done emitting values. If the ",(0,a.mdx)("inlineCode",{parentName:"p"},"CANCEL")," event happens, the observable will be disposed of as ",(0,a.mdx)("inlineCode",{parentName:"p"},".unsubscribe()")," will be called internally."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, interpret } from 'xstate';\nimport { interval } from 'rxjs';\nimport { map, take } from 'rxjs/operators';\n\nconst intervalMachine = createMachine({\n  initial: 'counting',\n  context: { myInterval: 1000 },\n  states: {\n    counting: {\n      invoke: {\n        src: (context, event) =>\n          interval(context.myInterval).pipe(\n            map((value) => ({ type: 'COUNT', value })),\n            take(5)\n          ),\n        onDone: 'finished',\n      },\n      on: {\n        COUNT: { actions: 'notifyCount' },\n        CANCEL: { target: 'finished' },\n      },\n    },\n    finished: {\n      type: 'final',\n    },\n  },\n});\n")),(0,a.mdx)("h3",{id:"hot-observables"},"Hot observables"),(0,a.mdx)("p",null,"You don\u2019t necessarily need to create observables for every invocation. You could reference a \u201chot observable\u201d instead:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-ts"},"import { fromEvent } from 'rxjs';\nimport { createMachine } from 'xstate';\n\nconst mouseMove$ = fromEvent(document.body, 'mousemove');\n\nconst mouseMachine = createMachine({\n  id: 'mouse',\n  // ...\n  invoke: {\n    src: (context, event) => mouseMove$,\n  },\n  on: {\n    mousemove: {\n      /* ... */\n    },\n  },\n});\n")))}p.isMDXComponent=!0}}]);