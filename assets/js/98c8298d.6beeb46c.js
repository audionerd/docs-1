"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[11804],{3905:(e,t,a)=>{a.r(t),a.d(t,{MDXContext:()=>d,MDXProvider:()=>h,mdx:()=>g,useMDXComponents:()=>c,withMDXComponents:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},s.apply(this,arguments)}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=n.createContext({}),m=function(e){return function(t){var a=c(t.components);return n.createElement(e,s({},t,{components:a}))}},c=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(a),h=i,u=m["".concat(o,".").concat(h)]||m[h]||p[h]||s;return a?n.createElement(u,r(r({ref:t},d),{},{components:a})):n.createElement(u,r({ref:t},d))}));function g(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var d=2;d<s;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},96024:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var n=a(87462),i=(a(67294),a(3905));const s={title:"You don\u2019t need a library for state machines",description:"Do you need a library to create and interpret state machines in your programs? No. But there are more things to consider.",tags:["finite state machine","statechart","xstate","state machine"],authors:["david"],image:"/blog/2021-01-20-you-dont-need-a-library-for-state-machines.png",slug:"2021-01-20-you-dont-need-a-library-for-state-machines",date:new Date("2021-01-20T00:00:00.000Z")},o=void 0,r={permalink:"/statelyai-docs/blog/2021-01-20-you-dont-need-a-library-for-state-machines",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2021-01-20-you-dont-need-a-library-for-state-machines/index.mdx",source:"@site/blog/2021-01-20-you-dont-need-a-library-for-state-machines/index.mdx",title:"You don\u2019t need a library for state machines",description:"Do you need a library to create and interpret state machines in your programs? No. But there are more things to consider.",date:"2021-01-20T00:00:00.000Z",formattedDate:"January 20, 2021",tags:[{label:"finite state machine",permalink:"/statelyai-docs/blog/tags/finite-state-machine"},{label:"statechart",permalink:"/statelyai-docs/blog/tags/statechart"},{label:"xstate",permalink:"/statelyai-docs/blog/tags/xstate"},{label:"state machine",permalink:"/statelyai-docs/blog/tags/state-machine"}],readingTime:12.765,hasTruncateMarker:!0,authors:[{name:"David Khourshid",title:"Stately Team",url:"https://github.com/davidkpiano",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/david.png",key:"david"}],frontMatter:{title:"You don\u2019t need a library for state machines",description:"Do you need a library to create and interpret state machines in your programs? No. But there are more things to consider.",tags:["finite state machine","statechart","xstate","state machine"],authors:["david"],image:"/blog/2021-01-20-you-dont-need-a-library-for-state-machines.png",slug:"2021-01-20-you-dont-need-a-library-for-state-machines",date:"2021-01-20T00:00:00.000Z"},prevItem:{title:"What\u2019s the difference between Machine and createMachine?",permalink:"/statelyai-docs/blog/2021-04-28-whats-the-difference-between-machine-and-createmachine"},nextItem:{title:"\u201cJust use props\u201d: An opinionated guide to React and XState",permalink:"/statelyai-docs/blog/2021-01-11-just-use-props-an-opinionated-guide-to-react-and-xstate"}},l={authorsImageUrls:[void 0]},d=[{value:"You probably need state machines",id:"you-probably-need-state-machines",level:2},{value:"You don\u2019t need a library for state machines",id:"you-dont-need-a-library-for-state-machines",level:2},{value:"Using <code>switch</code> statements",id:"using-switch-statements",level:3},{value:"Using <code>switch</code> statements with functions",id:"using-switch-statements-with-functions",level:3},{value:"Using objects",id:"using-objects",level:3},{value:"State machines aren&#39;t enough",id:"state-machines-arent-enough",level:2},{value:"Implementing statecharts",id:"implementing-statecharts",level:2},{value:"So do you need a library for statecharts?",id:"so-do-you-need-a-library-for-statecharts",level:2},{value:"Closing thoughts",id:"closing-thoughts",level:2}],m={toc:d};function c(e){let{components:t,...a}=e;return(0,i.mdx)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("head",null,(0,i.mdx)("link",{rel:"canonical",href:"https://dev.to/davidkpiano/you-don-t-need-a-library-for-state-machines-k7h"})),(0,i.mdx)("p",null,"The finite state machine is one of the oldest models of computation in computer science. It\u2019s older than the web, older than any programming language you can think of, and probably older than you. Just ask ",(0,i.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mealy_machine"},"Mealy (1955)")," or ",(0,i.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Moore_machine"},"Moore (1956)"),". Finite state machines (FSMs) can be implemented in any modern language using control-flow statements, yet there\u2019s most likely a state machine library (if not many) in all of those languages."),(0,i.mdx)("p",null,"So do you need a library to create and interpret state machines in your programs?"),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"No.")," But there are more things to consider."),(0,i.mdx)("h2",{id:"you-probably-need-state-machines"},"You probably need state machines"),(0,i.mdx)("p",null,"If you\u2019re unfamiliar with ",(0,i.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Finite-state_machine"},"finite state machines (FSMs)"),", they are a visual and mathematical way of modeling stateful logic using 3 main building blocks:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Finite states"),", which represent different ",(0,i.mdx)("em",{parentName:"li"},"behaviors")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Events"),", which represent something that happened that can change state"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Transitions"),", which represent how the state can change and what actions are executed when an event is received")),(0,i.mdx)("p",null,(0,i.mdx)("img",{parentName:"p",src:"https://res.cloudinary.com/practicaldev/image/fetch/s--NRBTk8Po--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/7ri5sbbrufj26cq3u026.png",alt:"States, events, and transitions"})),(0,i.mdx)("p",null,"Anything that can be described as changes in state over time due to events, from component-specific logic to application flows and even the orchestration of multiple services can be described with state machines, to some extent."),(0,i.mdx)("p",null,'A state machine might be a different, unfamiliar way of thinking about your application logic, but they\u2019re extremely useful. Instead of approaching logic from a "bottom-up" perspective (imperatively doing things based on events), they take a "top-down" approach and primarily consider ',(0,i.mdx)("em",{parentName:"p"},"behaviors"),", which describe how the logic will react to events in a given finite state (such as ",(0,i.mdx)("inlineCode",{parentName:"p"},"loading"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"editing"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"disabled"),", etc.)."),(0,i.mdx)("p",null,"Because of their explicit, declarative nature, state machines force you to think about the entire flow of your logic (including all the edge-cases), and make it virtually impossible to end up in an \u201dimpossible state\u201d, as long as your model doesn\u2019t allow it. Only defined transitions can happen; and if an unexpected transition happens, it means there is an implicit state machine where that transition ",(0,i.mdx)("em",{parentName:"p"},"does")," exist. The goal of state machines is to eliminate the implicit transitions so that we can know exactly what can happen in any state for any potential event."),(0,i.mdx)("p",null,"State machines are ",(0,i.mdx)("strong",{parentName:"p"},"not a solution for everything")," - just like anything else, they make sense for some use-cases (workflows, processes, modes, statuses, etc.) but not all use-cases. You shouldn\u2019t use state machines everywhere, or even implement them explicitly all of the time (that\u2019s what abstractions are for). They make a good refactor target, and they\u2019re great for visually modeling your logic with pencil and paper, even if you ultimately decide not to use them in your code. But when working with logic that deals with explicit states, events, and transitions (which, surprise, tends to be the majority of app logic), state machines are a brilliant, natural solution."),(0,i.mdx)("p",null,"There are so many other benefits to thinking in terms of states, events, and transitions, but that\u2019s not the point of this post (but it is the point of ",(0,i.mdx)("a",{parentName:"p",href:"https://dev.to/davidkpiano/no-disabling-a-button-is-not-app-logic-598i"},"another post I wrote"),"). Let\u2019s say you\u2019re already convinced in using state machines in parts of your app. Should you reach for a library?"),(0,i.mdx)("h2",{id:"you-dont-need-a-library-for-state-machines"},"You don\u2019t need a library for state machines"),(0,i.mdx)("p",null,"Since state machines are not a new concept and can be implemented in any modern language using built-in language features, it follows that state machine libraries are not necessary. Again, all you need are the 3 building blocks:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Finite states")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Events")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Transitions"))),(0,i.mdx)("p",null,"The transitions are what tie everything together. Transitions are represented by a ",(0,i.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Finite-state_machine#Mathematical_model"},"state-transition function")," that looks like this, mathematically:"),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},"\ud835\udec5 : \ud835\udc46 \ud835\uddd1 \ud835\udef4 \u2192 \ud835\udc46")),(0,i.mdx)("p",null,"\u2026which might not make sense (even if you do speak Greek). This might be more understandable:"),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},"transition : (state, event) => nextState")),(0,i.mdx)("p",null,"In JavaScript, we can represent this as a ",(0,i.mdx)("em",{parentName:"p"},"reducer"),", which is a function that reduces values (events) to a single accumulated value (state):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"function transition(state, event) {\n  // state machine goes here, which\n  // determines the next state based on the\n  // current state + received event\n  // ...\n\n  return nextState;\n}\n")),(0,i.mdx)("p",null,"Now, let\u2019s draw the rest of the owl implement the rest of the state machine!"),(0,i.mdx)("h3",{id:"using-switch-statements"},"Using ",(0,i.mdx)("inlineCode",{parentName:"h3"},"switch")," statements"),(0,i.mdx)("p",null,"Typically, when we\u2019re determining ",(0,i.mdx)("em",{parentName:"p"},"behavior"),' ("what happens next"), we tend to decide what should happen next based on the ',(0,i.mdx)("em",{parentName:"p"},"event"),". The finite state is an after-thought, if it\u2019s even a consideration at all. This leads to fragile logic, with ",(0,i.mdx)("inlineCode",{parentName:"p"},"if"),"-","statements strewn all over the place:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"    // \u274c Event-first approach\n    switch (event.type) {\n      case 'DATA_RECEIVED':\n        // defensive programming\n        if (state.isLoading) {\n          // do something\n        } else {\n          // ...\n        }\n      }\n      // ...\n    }\n")),(0,i.mdx)("p",null,"In contrast, state machines group behavior by ",(0,i.mdx)("strong",{parentName:"p"},"finite state")," and narrow down what happens next based on the event received:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'// \u2705 Finite-state-first approach\nswitch (state.status) {\n  case "loading":\n    // narrow based on event\n    switch (event.type) {\n      case "DATA_RECEIVED":\n      // do something, and possibly\n      // change the finite state\n      // ...\n    }\n  // ...\n}\n')),(0,i.mdx)("p",null,"As the author of the code, the event-first (bottom-up) approach might seem fine to you; after all, if it works, it works. One of the main advantages of taking a \u201dfinite-state-first\u201d (top-down) approach and using state machines is that the logic is not only more clear (since it\u2019s grouped by finite state), it\u2019s more robust: you can ensure that an event won\u2019t be improperly handled in a state that it shouldn\u2019t be handled in. In other words, you prevent ",(0,i.mdx)("em",{parentName:"p"},"impossible states")," and ",(0,i.mdx)("em",{parentName:"p"},"impossible transitions")," without having to litter your code with ",(0,i.mdx)("inlineCode",{parentName:"p"},"if"),"-","statements and excessive defensive programming."),(0,i.mdx)("p",null,"I also like to think of state machines as a formal way of communicating logic. If you were describing the above logic, here\u2019s how it would sound with an event-first approach:"),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},'When data is received, do something, but only if the "loading" flag is true.')),(0,i.mdx)("p",null,"And with a finite-state-first approach:"),(0,i.mdx)("blockquote",null,(0,i.mdx)("p",{parentName:"blockquote"},"In the \u201dloading\u201d state, when data is received, do something.")),(0,i.mdx)("p",null,"Which one sounds more natural and easy to understand? To me, there is less cognitive load with the 2nd statement. Reactions to events are grouped by ",(0,i.mdx)("em",{parentName:"p"},"behavior")," (finite state) rather than being ungrouped."),(0,i.mdx)("h3",{id:"using-switch-statements-with-functions"},"Using ",(0,i.mdx)("inlineCode",{parentName:"h3"},"switch")," statements with functions"),(0,i.mdx)("p",null,"Since finite states can be considered a way to group behavior, another way you can organize your ",(0,i.mdx)("inlineCode",{parentName:"p"},"switch")," statements is by \u201cgrouping\u201d each finite state\u2019s behavior into a function:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"    // 'loading' behavior\n    function loadingState(state, event) {\n      // switch only on the event\n      switch (event.type) {\n        case 'DATA_RECEIVED':\n          return {\n            ...state,\n            status: 'success'\n          }\n        }\n        // ...\n      }\n    }\n\n    function dataMachine(state, event) {\n      switch (state.status) {\n        case 'loading':\n          // handle the event with 'loading' behavior\n          return loadingState(state, event);\n        }\n        // ...\n      }\n    }\n")),(0,i.mdx)("p",null,"This approach is outlined in the ",(0,i.mdx)("a",{parentName:"p",href:"https://redux.js.org/style-guide/style-guide/#treat-reducers-as-state-machines"},"Redux style guide recommendation: Treat Reducers as State Machines"),". It\u2019s a very organized approach, and each \u201cbehavior function\u201d can be individually tested, since they are isolated, pure reducers."),(0,i.mdx)("h3",{id:"using-objects"},"Using objects"),(0,i.mdx)("p",null,"Using nested ",(0,i.mdx)("inlineCode",{parentName:"p"},"switch")," statements may feel verbose, and while using functions to organize these ",(0,i.mdx)("inlineCode",{parentName:"p"},"switch")," statements may look cleaner, it\u2019s more tedious. After all, a state transition can be considered a configuration of (at least) 2 things based on the event received:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The next ",(0,i.mdx)("strong",{parentName:"li"},"finite state"),", if it changes"),(0,i.mdx)("li",{parentName:"ul"},"Any ",(0,i.mdx)("strong",{parentName:"li"},"action(s)")," executed, if any")),(0,i.mdx)("p",null,"A simple, built-in way to represent such a configuration is an object. We can create an object structure where each \u201dstate node\u201d represents a finite state with transitions for each event accepted by the state:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'const machine = {\n  initial: "loading",\n  states: {\n    // A finite "state node"\n    loading: {\n      on: {\n        // event types\n        DATA_RECEIVED: {\n          target: "success",\n          // actions: [...]\n        },\n      },\n    },\n    // ...\n  },\n};\n// ...\n')),(0,i.mdx)("p",null,"This is much more succinct than the nested ",(0,i.mdx)("inlineCode",{parentName:"p"},"switch")," statements! From here, determining the next state based on the current finite state and received event is two key lookups (the finite state and the event type):"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'// ...\nfunction transition(state, event) {\n  const nextStateNode = // lookup next finite state based on event type\n    // lookup configuration for current finite state\n    machine.states[state.status].on?.[event.type] ?? { target: state.status }; // if not handled, stay on current state\n\n  return {\n    ...state,\n    status: nextStateNode.target,\n  };\n}\n\ntransition({ status: "loading" }, { type: "DATA_RECEIVED" });\n// => { status: \'success\', ... }\n')),(0,i.mdx)("p",null,"You might be wondering why I didn\u2019t use an even simpler object here, which you definitely can do:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'const transitions = {\n  loading: {\n    DATA_RECEIVED: "success",\n  },\n  success: {\n    /* ... */\n  },\n};\n\nfunction transition(state, event) {\n  const nextStateTarget = transitions[state.status][event.type] ?? state.status;\n\n  return {\n    ...state,\n    status: nextStateTarget,\n  };\n}\n')),(0,i.mdx)("p",null,"In fact, I would encourage the above implementation as sort of a \u201ctransition table lookup\u201d; it works, and it\u2019s simple enough. However, state machines deal with more than just the next finite state; if we want to encode ",(0,i.mdx)("strong",{parentName:"p"},"actions")," (state machine terminology for effects), we need a place to put them, so a little bit more structure is necessary."),(0,i.mdx)("p",null,"For instance, if our ",(0,i.mdx)("inlineCode",{parentName:"p"},"DATA_RECEIVED")," event returns data that we want to save in our overall state, it might be convenient to place that \u201cassign to state\u201d action directly in the machine:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},'const machine = {\n  initial: "loading",\n  states: {\n    loading: {\n      on: {\n        // event types\n        DATA_RECEIVED: {\n          target: "success",\n          // represents what "effects" should happen\n          // as a result of taking this transition\n          actions: [{ type: "saveData" }],\n        },\n      },\n    },\n    // ...\n  },\n};\n\nfunction transition(state, event) {\n  const nextStateNode = machine.states[state.status].on?.[event.type] ?? {\n    target: state.status,\n  };\n\n  const nextState = {\n    ...state,\n    status: nextStateNode.target,\n  };\n\n  // go through the actions to determine\n  // what should be done\n  nextStateNode.actions?.forEach((action) => {\n    if (action.type === "saveData") {\n      nextState.data = event.data;\n    }\n  });\n\n  return nextState;\n}\n')),(0,i.mdx)("p",null,"The implementation above is very small, accomplishes everything we want from a state machine (for this use-case, at least), and as a bonus, you can copy-paste the ",(0,i.mdx)("inlineCode",{parentName:"p"},"machine")," object code directly into the ",(0,i.mdx)("a",{parentName:"p",href:"https://xstate.js.org/viz"},"XState Visualizer"),", even though it's not using XState, or any libraries, at all! (Tip: wrap the object in ",(0,i.mdx)("inlineCode",{parentName:"p"},"Machine({ ... })")," to get it working)."),(0,i.mdx)("p",null,"Kent C. Dodds made a similar implementation is his post ",(0,i.mdx)("a",{parentName:"p",href:"https://kentcdodds.com/blog/implementing-a-simple-state-machine-library-in-javascript"},"Implementing a Simple State Machine Library in JavaScript"),". It also takes advantage of using objects for describing the state machine structure."),(0,i.mdx)("h2",{id:"state-machines-arent-enough"},"State machines aren't enough"),(0,i.mdx)("p",null,"So if we can get our basic state management needs met with a small, declarative, library-free state machine implementation (either using ",(0,i.mdx)("inlineCode",{parentName:"p"},"switch")," statements or objects), why do we need libraries such as ",(0,i.mdx)("a",{parentName:"p",href:"https://github.com/davidkpiano/xstate"},"XState"),"?"),(0,i.mdx)("p",null,"This might be a bit of a shock coming from me, but I\u2019ll say it: ",(0,i.mdx)("em",{parentName:"p"},"state machines are not sufficient")," for managing and orchestrating state at scale. State machines suffer from a fundamental problem called ",(0,i.mdx)("a",{parentName:"p",href:"https://statecharts.github.io/state-machine-state-explosion.html"},"state explosion"),": when the number of states in a state machine grow, the transitions between states also tend to grow, ",(0,i.mdx)("em",{parentName:"p"},"exponentially"),"."),(0,i.mdx)("p",null,"Thankfully, an extension to the traditional formalism of state machines, known as ",(0,i.mdx)("strong",{parentName:"p"},"statecharts"),", was invented by Prof. David Harel and published in his paper ",(0,i.mdx)("a",{parentName:"p",href:"https://www.sciencedirect.com/science/article/pii/0167642387900359/pdf"},"Statecharts: A Visual Formalism for Complex Systems"),". The paper is full of diagrams and is quite readable; I strongly encourage you to read it."),(0,i.mdx)("p",null,"You can think of statecharts as essentially being state machines (statecharts can be decomposed into FSMs) with some essential features for better state organization and real-world use-cases:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Hierarchy")," (nested states)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Orthogonality")," (parallel states)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"History")," (remembered states)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"State actions")," (entry, exit)"),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Guarded transitions")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Extended state")," (contextual data)")),(0,i.mdx)("p",null,"Notably, the first two features (hierarchy and orthogonality) mitigate the state explosion problem by allowing state nodes to be grouped in a way that reduces the number of transitions necessary to fully express all possible transitions."),(0,i.mdx)("p",null,"For example, if you were creating a state machine to represent editing and asynchronously saving some data, and you wanted to have shared behavior between some \u201didle\u201d (before saving) and \u201cerror\u201d (failure after saving) state (e.g., ",(0,i.mdx)("inlineCode",{parentName:"p"},"SUBMIT")," to try/retry), then instead of having a flat state machine:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"    {\n      idleNormal: {\n        on: {\n          SAVE: {\n            target: 'saving',\n            actions: [{ type: 'saveAsync' }]\n          }\n        }\n      },\n      saving: {/* ... */},\n      idleError: {\n        on: {\n          SAVE: {\n            target: 'saving',\n            actions: [{ type: 'saveAsync' }]\n          }\n        }\n      },\n      // ...\n    }\n\n")),(0,i.mdx)("p",null,"You can represent the shared behavior under the same parent state:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-js"},"    {\n      idle: {\n        // if child states don't handle these events,\n        // handle it here, in the parent state\n        on: {\n          SAVE: {\n            target: 'saving',\n            actions: [{ type: 'saveAsync' }]\n          }\n        },\n        initial: 'normal',\n        states: {\n          normal: {/* ... */},\n          error: {/* ... */}\n        }\n      },\n      saving: {/* ... */},\n      // ...\n    }\n")),(0,i.mdx)("p",null,"Overall, the features of statecharts are very useful in many different situations:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Nested states")," are useful for grouping and refining behavior. Different \u201dfinite states\u201d can all share behavior, while all having their own specific behavior."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Parallel states")," are useful for representing behaviors that can occur simultaneously, without directly affecting each other."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"History states")," are useful for recalling which nested state the machine was previously in without having to specify all the possible \u201dremembering\u201d transitions."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"State actions")," are useful for specifying actions that should always be executed on any transition that enters/exits a state without having to specify those actions in all incoming/outgoing transitions."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Guarded transitions")," are very important for conditionally taking transitions based on more than just the state and event type. They can take other data (extended state) and/or event data into consideration, as well."),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("strong",{parentName:"li"},"Extended state")," is absolutely necessary. Not all state is finite; \u201dinfinite\u201d state also needs to be quantified. Statecharts allow you to distinguish between finite and extended state.")),(0,i.mdx)("p",null,"There's even more features of classic statecharts, such as \u201dactivities\u201d (actions that occur ",(0,i.mdx)("em",{parentName:"p"},"throughout")," a state), delays, eventless transitions, wildcard transitions, and more. And the more you work with statecharts, the more you realize just how essential most of these features actually are."),(0,i.mdx)("p",null,"Sounds like it would be fun to implement these features on top of our state machines, right?"),(0,i.mdx)("h2",{id:"implementing-statecharts"},"Implementing statecharts"),(0,i.mdx)("p",null,"I hope you have a ",(0,i.mdx)("em",{parentName:"p"},"lot")," of free time."),(0,i.mdx)("p",null,"Since statecharts are more powerful than state machines, they\u2019re also harder to implement. If you\u2019re really curious and/or eager to implement them yourself, I strongly recommend following the ",(0,i.mdx)("a",{parentName:"p",href:"https://www.w3.org/TR/scxml"},"W3 SCXML (Statechart XML) spec"),". They even include ",(0,i.mdx)("a",{parentName:"p",href:"https://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation"},"an algorithm in pseudocode")," for proper SCXML interpretation."),(0,i.mdx)("p",null,"Even implementing something as seemingly straightforward as nested states is a daunting task. There are many rules about selecting transitions, resolving conflicting transitions, traversing the state node tree to determine which nodes are being exited/entered, selecting transitions in compound states if leaf nodes don't handle the event, determining action order, etc. etc."),(0,i.mdx)("p",null,"It\u2019s not easy, and just like you would use a date library to deal with timezones, you definitely want to use a statechart library to deal with all the excellent features that statecharts support."),(0,i.mdx)("h2",{id:"so-do-you-need-a-library-for-statecharts"},"So do you need a library for statecharts?"),(0,i.mdx)("p",null,"Yes."),(0,i.mdx)("h2",{id:"closing-thoughts"},"Closing thoughts"),(0,i.mdx)("p",null,"If you\u2019re satisfied manipulating state at any time and sprinkling ",(0,i.mdx)("inlineCode",{parentName:"p"},"if"),"-","statements to patch up edge-cases, you probably don\u2019t need explicit state machines."),(0,i.mdx)("p",null,"If you want to use simple state machines to help organize app behavior and logic, you don\u2019t need a library."),(0,i.mdx)("p",null,"If you have complex logic and want to take advantage of more powerful state machine features to better manage this logic, you need statecharts."),(0,i.mdx)("p",null,"And you ",(0,i.mdx)("em",{parentName:"p"},"definitely")," need a library for statecharts. \ud83d\ude09"))}c.isMDXComponent=!0}}]);