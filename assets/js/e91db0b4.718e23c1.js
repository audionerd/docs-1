"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[14145],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>f,mdx:()=>h,useMDXComponents:()=>m,withMDXComponents:()=>l});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},i.apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),l=function(e){return function(n){var t=m(n.components);return a.createElement(e,i({},n,{components:t}))}},m=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},f=function(e){var n=m(e.components);return a.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),l=m(t),f=r,p=l["".concat(o,".").concat(f)]||l[f]||u[f]||i;return t?a.createElement(p,s(s({ref:n},d),{},{components:t})):a.createElement(p,s({ref:n},d))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},94882:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=t(87462),r=(t(67294),t(3905));const i={title:"Guards"},o="Guards",s={unversionedId:"xstate/transitions-and-choices/guards",id:"version-4/xstate/transitions-and-choices/guards",title:"Guards",description:"A guard is a condition that the machine checks when it goes through an event. If the condition is true, the transition can be taken. If the condition is false, the next potential transition is tested to determine if it can be taken. Any transition can be a guarded transition.",source:"@site/versioned_docs/version-4/xstate/transitions-and-choices/guards.mdx",sourceDirName:"xstate/transitions-and-choices",slug:"/xstate/transitions-and-choices/guards",permalink:"/docs/xstate-v4/xstate/transitions-and-choices/guards",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/versioned_docs/version-4/xstate/transitions-and-choices/guards.mdx",tags:[],version:"4",frontMatter:{title:"Guards"},sidebar:"tutorialSidebar",previous:{title:"Transitions and choices",permalink:"/docs/xstate-v4/category/xstate-transitions-and-choices"},next:{title:"Guarded actions",permalink:"/docs/xstate-v4/xstate/transitions-and-choices/guarded-actions"}},c={},d=[{value:"Which transitions can be guarded?",id:"which-transitions-can-be-guarded",level:3}],l={toc:d};function m(e){let{components:n,...t}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.mdx)("h1",{id:"guards"},"Guards"),(0,r.mdx)("p",null,"A guard is a condition that the machine checks when it goes through an event. If the condition is true, the transition can be taken. If the condition is false, the next potential transition is tested to determine if it can be taken. Any transition can be a guarded transition."),(0,r.mdx)("p",null,"A common pattern in any program is if/else logic \u2014 the ability to make decisions based on inputs. The best way to apply if/else logic with statecharts is through ",(0,r.mdx)("em",{parentName:"p"},"guarded transitions"),"."),(0,r.mdx)("p",null,"In the following example, we\u2019ll imagine you want to order a decaf coffee at a cafe. You can send the ",(0,r.mdx)("inlineCode",{parentName:"p"},"ORDER_DECAF")," event to the barista, but the cafe might not have decaf coffee available! The machine for the ordering process could be as follows:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst baristaMachine = createMachine(\n  {\n    initial: 'receivingOrder',\n    states: {\n      receivingOrder: {\n        on: {\n          /**\n           * Guarded transitions are expressed\n           * as an array\n           */\n          ORDER_DECAF: [\n            {\n              /**\n               * 'cond' stands for condition\n               */\n              cond: 'hasDecaf',\n              target: 'makingDecafCoffee',\n            },\n          ],\n        },\n      },\n      makingDecafCoffee: {},\n    },\n  },\n  {\n    guards: {\n      /**\n       * Implement the guard below\n       */\n      hasDecaf: (context, event) => false,\n    },\n  }\n);\n")),(0,r.mdx)("p",null,"The machine above will only go to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"makingDecafCoffee")," state if the ",(0,r.mdx)("inlineCode",{parentName:"p"},"hasDecaf")," guard returns ",(0,r.mdx)("inlineCode",{parentName:"p"},"true"),". You might have noticed that guards take similar arguments to actions."),(0,r.mdx)("p",null,"You can also provide multiple guards to the same transition. In the example below, the machine checks if the customer is okay with regular coffee if decaf is unavailable:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst baristaMachine = createMachine(\n  {\n    initial: 'receivingOrder',\n    states: {\n      receivingOrder: {\n        on: {\n          ORDER_DECAF: [\n            {\n              cond: 'hasDecaf',\n              target: 'makingDecafCoffee',\n            },\n            {\n              cond: 'customerIsOkWithRegularCoffee',\n              target: 'makingRegularCoffee',\n            },\n          ],\n        },\n      },\n      makingDecafCoffee: {},\n      makingRegularCoffee: {},\n    },\n  },\n  {\n    guards: {\n      hasDecaf: (context, event) => false,\n      customerIsOkWithRegularCoffee: (context, event) => false,\n    },\n  }\n);\n")),(0,r.mdx)("p",null,"The code above is similar to a normal JavaScript function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const makeDecafCoffee = () => {};\nconst makeRegularCoffee = () => {};\nconst hasDecaf = false;\nconst customerIsOKWithRegularCoffee = false;\n\n\nif (hasDecaf) {\n  makeDecafCoffee();\n} else if (customerIsOKWithRegularCoffee) {\n  makeRegularCoffee();\n}\n")),(0,r.mdx)("p",null,"To add an ",(0,r.mdx)("inlineCode",{parentName:"p"},"else")," condition, you can create a transition without a ",(0,r.mdx)("inlineCode",{parentName:"p"},"cond")," at the end of the array:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst baristaMachine = createMachine(\n  {\n    initial: 'receivingOrder',\n    states: {\n      receivingOrder: {\n        on: {\n          ORDER_DECAF: [\n            {\n              cond: 'hasDecaf',\n              target: 'makingDecafCoffee',\n            },\n            {\n              cond: 'customerIsOkWithRegularCoffee',\n              target: 'makingRegularCoffee',\n            },\n            {\n              target: 'wavingGoodbye',\n            },\n          ],\n        },\n      },\n      makingDecafCoffee: {},\n      makingRegularCoffee: {},\n      wavingGoodbye: {},\n    },\n  },\n  {\n    guards: {\n      hasDecaf: (context, event) => false,\n      customerIsOkWithRegularCoffee: (context, event) => false,\n    },\n  }\n);\n")),(0,r.mdx)("p",null,"In the example above, the machine goes to the ",(0,r.mdx)("inlineCode",{parentName:"p"},"wavingGoodbye")," state if ",(0,r.mdx)("inlineCode",{parentName:"p"},"hasDecaf")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"customerIsOkWithRegularCoffee")," are both false."),(0,r.mdx)("h3",{id:"which-transitions-can-be-guarded"},"Which transitions can be guarded?"),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"You can turn ANY transition into a guarded transition"),". Anywhere you can ",(0,r.mdx)("inlineCode",{parentName:"p"},"target: 'newState'"),", you can also add a ",(0,r.mdx)("inlineCode",{parentName:"p"},"cond")," property and express if/else logic."),(0,r.mdx)("p",null,"We\u2019ll learn about all the types of transitions in more depth later; here\u2019s a brief list: ",(0,r.mdx)("inlineCode",{parentName:"p"},"always"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"after"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"invoke.onDone"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"invoke.onError"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"state.onDone"),"."))}m.isMDXComponent=!0}}]);