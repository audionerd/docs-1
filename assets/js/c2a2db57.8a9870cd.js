"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[17372],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>d,MDXProvider:()=>p,mdx:()=>u,useMDXComponents:()=>m,withMDXComponents:()=>c});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(){return o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=a.createContext({}),c=function(e){return function(n){var t=m(n.components);return a.createElement(e,o({},n,{components:t}))}},m=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=m(e.components);return a.createElement(d.Provider,{value:n},e.children)},f={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=m(t),p=i,h=c["".concat(r,".").concat(p)]||c[p]||f[p]||o;return t?a.createElement(h,s(s({ref:n},d),{},{components:t})):a.createElement(h,s({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=t[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},28541:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(87462),i=(t(67294),t(3905));const o={title:"Final states"},r="Final states",s={unversionedId:"xstate/states/final-states",id:"version-4/xstate/states/final-states",title:"Final states",description:"When a machine reaches the final state, it can no longer receive any events, and anything running inside it is canceled and cleaned up. A machine can have multiple final states or no final states.",source:"@site/versioned_docs/version-4/xstate/states/final-states.mdx",sourceDirName:"xstate/states",slug:"/xstate/states/final-states",permalink:"/statelyai-docs/docs/xstate-v4/xstate/states/final-states",draft:!1,editUrl:"https://github.com/statelyai/docs/tree/main/versioned_docs/version-4/xstate/states/final-states.mdx",tags:[],version:"4",frontMatter:{title:"Final states"},sidebar:"tutorialSidebar",previous:{title:"Advanced transitions",permalink:"/statelyai-docs/docs/xstate-v4/xstate/states/advanced-transitions"},next:{title:"Parallel states",permalink:"/statelyai-docs/docs/xstate-v4/xstate/states/parallel-states"}},l={},d=[{value:"Composing parent and final states",id:"composing-parent-and-final-states",level:2},{value:"<code>onDone</code> cannot be defined on the machine\u2019s root",id:"ondone-cannot-be-defined-on-the-machines-root",level:3},{value:"<code>state.done</code>",id:"statedone",level:2}],c={toc:d};function m(e){let{components:n,...t}=e;return(0,i.mdx)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h1",{id:"final-states"},"Final states"),(0,i.mdx)("p",null,"When a machine reaches the ",(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/xstate-v4/states/final-states"},"final state"),", it can no longer receive any events, and anything running inside it is canceled and cleaned up. A machine can have multiple final states or no final states."),(0,i.mdx)("admonition",{type:"studio"},(0,i.mdx)("p",{parentName:"admonition"},(0,i.mdx)("a",{parentName:"p",href:"/statelyai-docs/docs/xstate-v4/states/final-states"},"Read more about how to use final states in the Stately Studio"),".")),(0,i.mdx)("p",null,"To indicate that a state node is final, set its ",(0,i.mdx)("inlineCode",{parentName:"p"},"type")," property to ",(0,i.mdx)("inlineCode",{parentName:"p"},"final"),":"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst machine = createMachine({\n  initial: 'waiting',\n  states: {\n    waiting: {\n      after: {\n        4000: 'stopped',\n      },\n    },\n    stopped: {\n      type: 'final',\n    },\n  },\n});\n")),(0,i.mdx)("p",null,"The machine above will wait for 4 seconds and then stop."),(0,i.mdx)("p",null,"When a machine reaches its final state, several things happen:"),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},"The machine stops being able to receive events"),(0,i.mdx)("li",{parentName:"ul"},"Any running timers/actors inside the machine are canceled and cleaned up")),(0,i.mdx)("p",null,"Final states give you the option for an idiomatic way of cleaning up your machine."),(0,i.mdx)("h2",{id:"composing-parent-and-final-states"},"Composing parent and final states"),(0,i.mdx)("p",null,"Final states can be used with parent states to make elegant, modular statecharts."),(0,i.mdx)("p",null,"Inside a parent state, reaching a final child state node will fire a ",(0,i.mdx)("inlineCode",{parentName:"p"},"done")," event back to the machine. The machine can listen for the ",(0,i.mdx)("inlineCode",{parentName:"p"},"done")," event by declaring ",(0,i.mdx)("inlineCode",{parentName:"p"},"onDone")," on the state:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine } from 'xstate';\n\nconst machine = createMachine({\n  initial: 'makingCoffee',\n  states: {\n    makingCoffee: {\n      initial: 'boilingWater',\n      states: {\n        boilingWater: {\n          on: {\n            WATER_BOILED: {\n              target: 'pouringWaterThroughPod',\n            },\n          },\n        },\n        pouringWaterThroughPod: {\n          on: {\n            WATER_POURED: {\n              target: 'complete',\n            },\n          },\n        },\n        complete: {\n          type: 'final',\n        },\n      },\n      onDone: {\n        target: 'coffeeMade',\n      },\n    },\n    coffeeMade: {},\n  },\n});\n")),(0,i.mdx)("p",null,"The machine above has two main states - ",(0,i.mdx)("inlineCode",{parentName:"p"},"makingCoffee")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"coffeeMade"),". ",(0,i.mdx)("inlineCode",{parentName:"p"},"makingCoffee")," has several sub-steps which end up in a ",(0,i.mdx)("inlineCode",{parentName:"p"},"complete")," state. When the machine reaches the ",(0,i.mdx)("inlineCode",{parentName:"p"},"complete")," state, it fires a ",(0,i.mdx)("inlineCode",{parentName:"p"},"done")," event, meaning the ",(0,i.mdx)("inlineCode",{parentName:"p"},"makingCoffee")," state is complete."),(0,i.mdx)("p",null,"Because the machine is listening for ",(0,i.mdx)("inlineCode",{parentName:"p"},"onDone")," on ",(0,i.mdx)("inlineCode",{parentName:"p"},"makingCoffee"),", the machine then transitions to ",(0,i.mdx)("inlineCode",{parentName:"p"},"coffeeMade"),"."),(0,i.mdx)("p",null,"Using ",(0,i.mdx)("inlineCode",{parentName:"p"},"onDone")," can make large statecharts easier to understand. The example above clearly shows that the overall \u201cstory\u201d of the machine is that it makes coffee, then the coffee is done. If you need to know how the coffee is made, you can dive into the details of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"makingCoffee")," state."),(0,i.mdx)("h3",{id:"ondone-cannot-be-defined-on-the-machines-root"},(0,i.mdx)("inlineCode",{parentName:"h3"},"onDone")," cannot be defined on the machine\u2019s root"),(0,i.mdx)("p",null,"The ",(0,i.mdx)("inlineCode",{parentName:"p"},"onDone")," transition cannot be defined on the machine\u2019s root because ",(0,i.mdx)("inlineCode",{parentName:"p"},"onDone")," is a transition on a ",(0,i.mdx)("inlineCode",{parentName:"p"},"'done.state.*'")," event, and when a machine reaches its final state, it can no longer accept any events."),(0,i.mdx)("h2",{id:"statedone"},(0,i.mdx)("inlineCode",{parentName:"h2"},"state.done")),(0,i.mdx)("p",null,"When running a machine, you can check ",(0,i.mdx)("inlineCode",{parentName:"p"},"state.done")," to find out if an actor has reached its final state."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, interpret } from 'xstate';\n\nconst answeringMachine = createMachine({\n  initial: 'unanswered',\n  states: {\n    unanswered: {\n      on: {\n        ANSWER: { target: 'answered' },\n      },\n    },\n    answered: {\n      type: 'final',\n    },\n  },\n});\n\nconst actor = interpret(answeringMachine).start();\n\nactor.send({\n  type: 'ANSWER',\n});\n\nactor.state.done; // true\n")))}m.isMDXComponent=!0}}]);