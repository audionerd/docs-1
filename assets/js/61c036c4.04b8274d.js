"use strict";(self.webpackChunkstately_docs=self.webpackChunkstately_docs||[]).push([[61019],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>p,mdx:()=>g,useMDXComponents:()=>m,withMDXComponents:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},o.apply(this,arguments)}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),d=function(e){return function(t){var n=m(t.components);return a.createElement(e,o({},t,{components:n}))}},m=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=m(n),p=r,h=d["".concat(i,".").concat(p)]||d[p]||u[p]||o;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},87713:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"Announcing XState v5 beta",description:"We\u2019re excited to announce the beta release of XState v5 and related packages after many years of development.",tags:["xstate","xstate v5","announcement","beta"],authors:["david"],slug:"announcing-xstate-v5-beta",image:"/blog/2023-05-25-announcing-xstate-v5-beta.png",date:new Date("2023-05-25T00:00:00.000Z")},i=void 0,s={permalink:"/statelyai-docs/blog/announcing-xstate-v5-beta",editUrl:"https://github.com/statelyai/docs/edit/main/blog/2023-05-25-announcing-xstate-v5-beta/index.mdx",source:"@site/blog/2023-05-25-announcing-xstate-v5-beta/index.mdx",title:"Announcing XState v5 beta",description:"We\u2019re excited to announce the beta release of XState v5 and related packages after many years of development.",date:"2023-05-25T00:00:00.000Z",formattedDate:"May 25, 2023",tags:[{label:"xstate",permalink:"/statelyai-docs/blog/tags/xstate"},{label:"xstate v5",permalink:"/statelyai-docs/blog/tags/xstate-v-5"},{label:"announcement",permalink:"/statelyai-docs/blog/tags/announcement"},{label:"beta",permalink:"/statelyai-docs/blog/tags/beta"}],readingTime:13.325,hasTruncateMarker:!0,authors:[{name:"David Khourshid",title:"Stately Team",url:"https://github.com/davidkpiano",imageURL:"https://ascelcgzufjyvdzuplwo.supabase.co/storage/v1/object/public/avatars/david.png",key:"david"}],frontMatter:{title:"Announcing XState v5 beta",description:"We\u2019re excited to announce the beta release of XState v5 and related packages after many years of development.",tags:["xstate","xstate v5","announcement","beta"],authors:["david"],slug:"announcing-xstate-v5-beta",image:"/blog/2023-05-25-announcing-xstate-v5-beta.png",date:"2023-05-25T00:00:00.000Z"},prevItem:{title:"Stately Studio minor improvements",permalink:"/statelyai-docs/blog/2023-05-26-stately-studio-minor-improvements"},nextItem:{title:"Context-aware search in the docs",permalink:"/statelyai-docs/blog/2023-05-19-context-aware-search"}},l={authorsImageUrls:[void 0]},c=[{value:"Flattening the learning curve",id:"flattening-the-learning-curve",level:2},{value:"Actor-first approach for any logic",id:"actor-first-approach-for-any-logic",level:2},{value:"Deep persistence",id:"deep-persistence",level:2},{value:"Actor system",id:"actor-system",level:2},{value:"Actor input",id:"actor-input",level:2},{value:"Unified arguments",id:"unified-arguments",level:2},{value:"Self reference",id:"self-reference",level:2},{value:"Higher-order guards",id:"higher-order-guards",level:2},{value:"Predictable events and actions",id:"predictable-events-and-actions",level:2},{value:"Partial event descriptors",id:"partial-event-descriptors",level:2},{value:"Examples",id:"examples",level:2},{value:"Migration and breaking changes",id:"migration-and-breaking-changes",level:2},{value:"In progress",id:"in-progress",level:2},{value:"Stately Studio",id:"stately-studio",level:2},{value:"We hope you enjoy XState v5 beta!",id:"we-hope-you-enjoy-xstate-v5-beta",level:2}],d=(m="Tweet",function(e){return console.warn("Component "+m+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.mdx)("div",e)});var m;const p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.mdx)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"We\u2019re excited to announce the v5 beta release of XState and related packages after many years of development."," XState is a powerful, fully open-source (MIT-licensed) and zero-dependency state management & orchestration solution based on state machines, statecharts, and the actor model. It is currently being used in production by many companies for both frontend and backend applications."),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"XState orchestrates any logic"),", from promises to state machines and everything in between."),(0,r.mdx)("p",null,"You can try out XState v5 beta today by installing ",(0,r.mdx)("inlineCode",{parentName:"p"},"xstate@beta"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-bash"},"yarn add xstate@beta\n")),(0,r.mdx)("p",null,(0,r.mdx)("strong",{parentName:"p"},"Note:")," XState v5 beta support in XState tools such as typegen, the visual inspector, and Stately Studio is still in progress. We appreciate your patience as we work to ensure full compatibility with XState v4 and v5 in all of the XState/Stately tools. For more information, see the ",(0,r.mdx)("a",{parentName:"p",href:"#in-progress"},"list of items in progress"),"."),(0,r.mdx)("p",null,"Over the past few years, we have collected a wealth of valuable feedback from the community regarding features they would like to see. These include ways to gradually adopt XState within their team and reduce the learning curve. We have responded by adding numerous new features and improvements that address these desires. Let\u2019s dive in and explore them!"),(0,r.mdx)("h2",{id:"flattening-the-learning-curve"},"Flattening the learning curve"),(0,r.mdx)("p",null,"One of the biggest items of feedback we\u2019ve received about XState is that although it is powerful, there is a substantial learning curve. There are some ",(0,r.mdx)("del",{parentName:"p"},"new")," old concepts to learn with XState, such as the actor model, state machines, and statecharts. With these concepts comes new terminology. In XState v5 beta and ",(0,r.mdx)("a",{parentName:"p",href:"https://stately.ai/docs/xstate-v5"},"the documentation"),", we have made a concerted effort to make XState as approachable as possible, and to reduce the learning curve as much as possible. Here are some of the changes we\u2019ve made:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("strong",{parentName:"li"},"Simplified terminology"),". Concepts shouldn\u2019t have multiple names, so we have simplified terms wherever possible. The basic unit of abstraction in XState v5 beta is the ",(0,r.mdx)("strong",{parentName:"li"},"actor"),', and we\u2019ve removed some of the more confusing terms, such as \u201cservice\u201d and \u201cinterpreter,\u201d \u201ctransient transitions\u201d to \u201ceventless transitions,\u201d \u201ccond\u201d to \u201cguard", \u201cinternal: false\u201d to \u201creenter: true,\u201d and ',(0,r.mdx)("a",{parentName:"li",href:"https://stately.ai/docs/migration"},"more"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("strong",{parentName:"li"},"Reduced API surface area"),". Some of the new features, such as ",(0,r.mdx)("a",{parentName:"li",href:"#actor-input"},"input")," made existing features redundant, such as ",(0,r.mdx)("inlineCode",{parentName:"li"},"machine.withContext(...)"),". We\u2019ve also removed redundant functionality, such as ",(0,r.mdx)("inlineCode",{parentName:"li"},"actor.onTransition(...)"),", in favor of ",(0,r.mdx)("inlineCode",{parentName:"li"},"actor.subscribe(...)"),". ",(0,r.mdx)("a",{parentName:"li",href:"https://stately.ai/docs/migration"},"Read about all the breaking changes"),"."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("strong",{parentName:"li"},"Examples, examples, examples"),". We\u2019re adding many ",(0,r.mdx)("a",{parentName:"li",href:"https://github.com/statelyai/xstate/tree/next/examples"},"XState v5 beta examples in the XState repository\u2019s examples folder")," to help you quickly understand how XState can help with your use cases."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("strong",{parentName:"li"},"Interactive documentation"),". We\u2019re working on adding interactive examples to the documentation, so you can visualize the concepts as you learn them."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("strong",{parentName:"li"},"From zero to \u201chello world\u201d as quickly as possible"),". Our goal with XState v5 and the ",(0,r.mdx)("a",{parentName:"li",href:"https://stately.ai/docs/xstate-v5"},"updated documentation (work in progress)")," is to make developers productive with XState quickly. A simple, complete counter example in XState looks like this:")),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, interpret, assign } from 'xstate';\n\nconst counterMachine = createMachine({\n  id: 'counter',\n  context: {\n    count: 0,\n  },\n  on: {\n    increment: {\n      actions: assign({ count: ({ context }) => context.count + 1 }),\n    },\n    decrement: {\n      actions: assign({ count: ({ context }) => context.count - 1 }),\n    },\n  },\n});\n\nconst counterActor = interpret(counterMachine);\ncounterActor.subscribe((state) => console.log(state.context.count));\ncounterActor.start();\n\ncounterActor.send({ type: 'increment' }); // logs 1\ncounterActor.send({ type: 'increment' }); // logs 2\ncounterActor.send({ type: 'decrement' }); // logs 1\n")),(0,r.mdx)("p",null,"This functionality is already capable of meeting the majority of state management needs for most applications. If you require more advanced use cases, have no fear - XState v5 beta has got you covered."),(0,r.mdx)("h2",{id:"actor-first-approach-for-any-logic"},"Actor-first approach for any logic"),(0,r.mdx)("p",null,"Actors are now first-class citizens. In v4, you could invoke/spawn promises, callbacks, observables, and other state machines, but these were special-cased, and you could only ",(0,r.mdx)("inlineCode",{parentName:"p"},"interpret()")," machines. In v5, you can invoke/spawn ",(0,r.mdx)("em",{parentName:"p"},"anything"),"; actors can be created from any type of logic, which can be invoked, spawned, or even interpreted:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import {\n  interpret,\n  fromPromise,\n  fromTransition,\n  fromObservable,\n  fromEventObservable,\n  fromCallback,\n  createMachine,\n} from 'xstate';\nimport { interval, fromEvent } from 'rxjs';\n\n// Promise logic\nconst promiseLogic = fromPromise(() => fetch('https://api.example.com/users'));\n\n// Transition logic\nconst transitionLogic = fromTransition(\n  (state, event) => {\n    if (event.type === 'increment') {\n      return { ...state, count: state.count + 1 };\n    } else if (event.type === 'decrement') {\n      return { ...state, count: state.count - 1 };\n    }\n\n    return state;\n  },\n  { count: 0 },\n);\n\n// Observable logic\nconst observableLogic = fromObservable(() => interval(1000));\n\n// Event observable logic\nconst eventObservableLogic = fromEventObservable(() =>\n  fromEvent(window, 'resize'),\n);\n\n// Callback logic\nconst callbackLogic = fromCallback(({ sendBack }) => {\n  const handler = (ev) => {\n    sendBack(ev);\n  };\n\n  window.addEventListener('resize', handler);\n\n  return () => {\n    window.removeEventListener('resize', handler);\n  };\n});\n\nconst machine = createMachine({\n  // Invoke any logic\n  invoke: {\n    src: callbackLogic,\n  },\n  // Spawn any logic\n  on: {\n    event: {\n      actions: assign({\n        promiseRef: ({ spawn }) => spawn(promiseLogic),\n      }),\n    },\n  },\n});\n\nconst actor = interpret(machine);\nactor.start();\n")),(0,r.mdx)("p",null,"The composable building block to this is \u201cactor logic,\u201d which is an object consisting of ",(0,r.mdx)("inlineCode",{parentName:"p"},".transition(...)"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},".getInitialState(...)"),", and ",(0,r.mdx)("inlineCode",{parentName:"p"},".getSnapshot()")," methods, among other useful properties and methods. XState v5 beta provides the following actor logic creators:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"createMachine(machineDef)"),": useful for more complex state machine/statechart logic; can spawn/invoke actors and declaratively handle effects"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"fromTransition(fn, initialState)"),": useful for basic reducer-like state management, similar to Redux, Zustand, Pinia, NgRx, etc."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"fromPromise(promiseFn)"),": useful for async/await promise-based logic"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"fromCallback(fn)"),": useful for subscription-based or other free-form logic that can send events back to the parent actor"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"fromObservable(observableFn)"),": useful for subscribing to an observable stream of values"),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"fromEventObservable(observableFn)"),": useful for subscribing to an observable stream of events")),(0,r.mdx)("p",null,"With this new actor logic abstraction, it is now possible to create your own actor logic for any use-case; imagine ",(0,r.mdx)("inlineCode",{parentName:"p"},"fromWebSocket(...)"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"fromQuery(...)"),", and ",(0,r.mdx)("inlineCode",{parentName:"p"},"fromWebWorker(...)")," logic creator functions. Furthermore, higher-order actor functions can be made that bring additional functionality to actors, such as ",(0,r.mdx)("inlineCode",{parentName:"p"},"withUndoRedo(actorLogic)")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"withLocalStoragePersistence(actorLogic)"),". We\u2019re still writing documentation and examples of these new patterns, so keep on the lookout for them."),(0,r.mdx)("h2",{id:"deep-persistence"},"Deep persistence"),(0,r.mdx)("p",null,"Actor persistence is a pattern where the internal state of an actor can be persisted and restored at any time. In XState v4, machines can invoke/spawn actors, but those child actors are not persisted. In XState v5 beta, actors are now deeply (recursively) persisted. Invoked/spawned actors will be persisted, as well as actors invoked/spawned from those actors, and so on."),(0,r.mdx)("p",null,"In the following example, the state of the ",(0,r.mdx)("inlineCode",{parentName:"p"},"mainActor")," will be persisted, as well as the state of the invoked ",(0,r.mdx)("inlineCode",{parentName:"p"},"someCounter")," actor. When the ",(0,r.mdx)("inlineCode",{parentName:"p"},"restoredActor")," is started, it will start at the persisted state of ",(0,r.mdx)("inlineCode",{parentName:"p"},"mainActor"),", which includes the persisted state of ",(0,r.mdx)("inlineCode",{parentName:"p"},"someCounter"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const machine = createMachine({\n  invoke: {\n    src: 'counter',\n    id: 'someCounter',\n  },\n  // ...\n});\n\nconst mainActor = interpret(machine);\nmainActor.start();\n\n// Deeply persist state\n// Also persists the \"someCounter\" actor!\nconst persistedState = mainActor.getPersistedState();\n\n// Restore state\nconst restoredActor = interpret(machine, {\n  state: persistedState,\n});\n\n// Starts at recursively persisted state\nrestoredActor.start();\n")),(0,r.mdx)("p",null,"This is useful for both client-side (e.g. handling page refreshes) and server-side (e.g. persisting workflow state) use cases. Customizing persistence/restoration logic for actors is also possible, and we will document those options soon."),(0,r.mdx)("h2",{id:"actor-system"},"Actor system"),(0,r.mdx)("p",null,"As actors can spawn other actors, which in turn can spawn other actors, these connected actors form a natural hierarchy. This collection of connected actors is known as an actor system."),(0,r.mdx)("p",null,"In XState v5 beta, calling ",(0,r.mdx)("inlineCode",{parentName:"p"},"interpret(...)")," to create a root actor will also create an implicit actor system. This enables a key feature called the ",(0,r.mdx)("strong",{parentName:"p"},"receptionist pattern"),". The receptionist pattern means actors can be registered and looked up by their ",(0,r.mdx)("inlineCode",{parentName:"p"},"systemId"),", which is useful for actors that need to communicate with each other but don\u2019t directly know about each other (i.e., actors not in a parent-child relationship)."),(0,r.mdx)("p",null,"For example, let\u2019s say you have a ",(0,r.mdx)("inlineCode",{parentName:"p"},"checkoutMachine")," that orchestrates the state of an online shop. If you want a notifier actor to be available to any machines spawned anywhere within the ",(0,r.mdx)("inlineCode",{parentName:"p"},"checkoutMachine")," system, you can register it by providing a ",(0,r.mdx)("inlineCode",{parentName:"p"},"systemId"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import { notifierMachine } from '../notifierMachine';\nimport { shippingMachine } from '../shippingMachine';\n\nconst checkoutMachine = createMachine({\n  invoke: {\n    src: notifierMachine,\n    systemId: 'notifier',\n  },\n  // ...\n  states: {\n    // ...\n    shipping: {\n      invoke: {\n        src: shippingMachine,\n      },\n    },\n  },\n});\n\nconst checkoutActor = interpret(checkoutMachine);\ncheckoutActor.start();\n")),(0,r.mdx)("p",null,"Now, any actor within the ",(0,r.mdx)("inlineCode",{parentName:"p"},"checkoutActor")," system can access the notifier actor by calling ",(0,r.mdx)("inlineCode",{parentName:"p"},'system.get("notifier")'),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const shippingMachine = createMachine({\n  // ...\n  on: {\n    'address.updated': {\n      actions: sendTo(({ system }) => system.get('notifier'), {\n        type: 'notify',\n        message: 'Shipping address updated',\n      }),\n    },\n  },\n});\n")),(0,r.mdx)("p",null,"The implicit system and receptionist pattern make it much easier to model arbitrary actor-to-actor communication, event buses, and other event-driven patterns."),(0,r.mdx)("h2",{id:"actor-input"},"Actor input"),(0,r.mdx)("p",null,"In some cases where you want to specify initial \u201cinput data\u201d for actors. Providing that input data in XState v4 was not easy. You had to either:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Create a factory machine function that took in some input data and returned a machine with that input data in context."),(0,r.mdx)("li",{parentName:"ul"},"Create a new machine with ",(0,r.mdx)("inlineCode",{parentName:"li"},"machine.withContext(...)")," and pass the entire context with the input data inside.")),(0,r.mdx)("p",null,"Since only the machine should initially determine ",(0,r.mdx)("inlineCode",{parentName:"p"},"context"),", this was not ideal, as it was possible to initialize a machine at some impossible state. Additionally, you may want to consider some ",(0,r.mdx)("inlineCode",{parentName:"p"},"context")," properties ",(0,r.mdx)("em",{parentName:"p"},"private")," (internal to the machine) and not externally configurable."),(0,r.mdx)("p",null,"In XState v5 beta, you can now provide input data to machines by passing it as the second argument to ",(0,r.mdx)("inlineCode",{parentName:"p"},"interpret(machine, { input })"),". This input data can be read by machines in the ",(0,r.mdx)("inlineCode",{parentName:"p"},"context")," initialization function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const greetingMachine = createMachine({\n  context: ({ input }) => ({\n    greeting: `Hello, ${input.name}!`,\n  }),\n});\n\nconst greetingActor = interpret(greetingMachine, {\n  input: {\n    name: 'David',\n  },\n});\n")),(0,r.mdx)("p",null,"Furthermore, this works for any actor logic, not just state machines:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const promiseLogic = fromPromise(({ input }) =>\n  fetch(`https://api.example.com/users/${input.id}`).then((res) => res.json()),\n);\n\nconst promiseActor = interpret(promiseLogic, {\n  input: {\n    id: 42,\n  },\n});\n")),(0,r.mdx)("h2",{id:"unified-arguments"},"Unified arguments"),(0,r.mdx)(d,{id:"1555175849569263618",mdxType:"Tweet"}),(0,r.mdx)("p",null,"The crowd has spoken. Most of you wanted a unified arguments object for all implementation functions. Implementation functions previously took multiple arguments, making it hard to remember which argument to use or awkward to ignore certain arguments. In XState v5 beta, all implementation functions now take a single unified argument object, which contains ",(0,r.mdx)("inlineCode",{parentName:"p"},"context"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"event"),", and other properties relevant to the implementation function:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const machine = createMachine({\n  context: {\n    count: 0,\n  },\n  on: {\n    increment: {\n      // Single argument, instead of:\n      // guard: (_, event) => ...\n      guard: ({ event }) => !Number.isNaN(event.value),\n      // Single argument, instead of:\n      // actions: (context, event) => ...\n      actions: ({ context, event }) => {\n        console.log(context, event);\n      },\n    },\n  },\n});\n")),(0,r.mdx)("h2",{id:"self-reference"},"Self reference"),(0,r.mdx)("p",null,"In the unified argument object, there is a ",(0,r.mdx)("inlineCode",{parentName:"p"},"self")," property that references the actor itself. This enables new, flexible patterns for actor communication, as you can pass this ",(0,r.mdx)("inlineCode",{parentName:"p"},"self")," reference to other actors in events:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"const pingMachine = createMachine({\n  invoke: {\n    src: 'pong',\n    id: 'pong',\n  },\n  on: {\n    ping: {\n      actions: sendTo('pong', ({ self }) => ({ type: 'ping', sender: self })),\n    },\n  },\n});\n\n// ...\n\nconst pongMachine = createMachine({\n  on: {\n    ping: {\n      actions: sendTo(({ event }) => event.sender, { type: 'pong' }),\n    },\n  },\n});\n")),(0,r.mdx)("h2",{id:"higher-order-guards"},"Higher-order guards"),(0,r.mdx)("p",null,"In XState v4, guards were simple functions on the ",(0,r.mdx)("inlineCode",{parentName:"p"},".cond")," transition property that returned ",(0,r.mdx)("inlineCode",{parentName:"p"},"true")," or ",(0,r.mdx)("inlineCode",{parentName:"p"},"false")," to determine if a transition would be taken. To negate a guard or combine guards, you had to create a new guard, which resulted in duplication or redundant code. In XState v5 beta, you can now use higher-order guards, which are functions that take in guards (referenced and/or inline) and return a guard function. There are 3 built-in higher-order guard functions: ",(0,r.mdx)("inlineCode",{parentName:"p"},"and([...guards])"),", ",(0,r.mdx)("inlineCode",{parentName:"p"},"or([...guards])"),", and ",(0,r.mdx)("inlineCode",{parentName:"p"},"not(guard)"),":"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, and, not } from 'xstate';\n\nconst userMachine = createMachine(\n  {\n    // ...\n    on: {\n      doSomething: {\n        // Higher-order guard\n        // Renamed from \"cond\" (v4) -> \"guard\" (v5)\n        guard: and(['isAuthenticated', 'isAdmin', not('isBanned')]),\n      },\n    },\n  },\n  {\n    guards: {\n      isAuthenticated: ({ context }) => context.user !== undefined,\n      isAdmin: ({ context }) => context.user.role === 'admin',\n      isBanned: ({ context }) => context.user.status === 'banned',\n    },\n  },\n);\n")),(0,r.mdx)("p",null,"These higher-order guards can be combined in many different ways to express any complex condition. In the future, Stately visual tooling will be able to visualize complex conditional logic expressed in guards."),(0,r.mdx)("h2",{id:"predictable-events-and-actions"},"Predictable events and actions"),(0,r.mdx)("p",null,"In XState v4, actions and events had nuanced default behavior: ",(0,r.mdx)("inlineCode",{parentName:"p"},"assign(...)")," actions were prioritized over other actions, which made action order less predictable. Additionally, events were ",(0,r.mdx)("em",{parentName:"p"},"nullified")," when going through eventless transitions, making it difficult to reference data from the original event. The ",(0,r.mdx)("inlineCode",{parentName:"p"},"predictableActionArguments: true")," flag was a necessary workaround for this. In XState v5 beta, actions are always executed in order, and events are always preserved, even when going through eventless transitions. No need for flags \u26f3\ufe0f:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-diff"},"const machine = createMachine({\n  // ...\n  // Action order is now predictable by default\n- predictableActionArguments: true,\n})\n")),(0,r.mdx)("h2",{id:"partial-event-descriptors"},"Partial event descriptors"),(0,r.mdx)("p",null,"Partial event descriptors, also known as ",(0,r.mdx)("em",{parentName:"p"},"partial wildcards"),", are a powerful new feature in XState v5 beta that makes it easier to handle groups of events. In XState v4, you could use wildcards to handle any event that wasn\u2019t matched by any other transition, but you had to be careful not to handle events that you didn\u2019t intend to handle accidentally. In XState v5 beta, you can use partial event descriptors to handle groups of events by placing a wildcard after the delimiter (",(0,r.mdx)("inlineCode",{parentName:"p"},".*"),"), and you can be explicit about which events you want to handle:"),(0,r.mdx)("pre",null,(0,r.mdx)("code",{parentName:"pre",className:"language-ts"},'const machine = createMachine({\n  // ...\n  on: {\n    // Will handle any event that starts with "pointer.":\n    // "pointer.down", "pointer.up", "pointer.move", etc.\n    \'pointer.*\': {\n      actions: \'logPointerEvent\',\n    },\n  },\n});\n')),(0,r.mdx)("h2",{id:"examples"},"Examples"),(0,r.mdx)("p",null,(0,r.mdx)("a",{parentName:"p",href:"https://codesandbox.io/p/sandbox/github/statelyai/xstate/tree/next/examples/todomvc-react"},"Check out the TodoMVC example with React, TypeScript, and XState v5 beta"),"."),(0,r.mdx)("p",null,"For more examples, ",(0,r.mdx)("a",{parentName:"p",href:"https://github.com/statelyai/xstate/tree/next/examples"},"visit the ",(0,r.mdx)("inlineCode",{parentName:"a"},"/examples")," directory in the XState repository"),"."),(0,r.mdx)("h2",{id:"migration-and-breaking-changes"},"Migration and breaking changes"),(0,r.mdx)("p",null,"As with any major version, there are some breaking changes. We\u2019ve tried to keep these to a minimum, but some are necessary to make XState v5 beta as powerful and flexible as possible. ",(0,r.mdx)("a",{parentName:"p",href:"https://stately.ai/docs/migration"},"Read our current guide for migrating from XState v4 to v5 and the list of breaking changes"),"."),(0,r.mdx)("h2",{id:"in-progress"},"In progress"),(0,r.mdx)("p",null,"XState v5 beta API is mostly stabilized, and there is still much work for us to do now we\u2019ve reached this milestone. We are working on the following:"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},"Type safety is a priority. We are working on using the latest TypeScript features to make XState v5 beta as type-safe as possible. This includes better type inference for as many parts of the machine as possible, including ",(0,r.mdx)("inlineCode",{parentName:"li"},"context"),", events, guards, actions, finite state values, and more. For everything that cannot be inferred or specified, we are updating ",(0,r.mdx)("a",{parentName:"li",href:"https://stately.ai/docs/xstate/typescript/typegen"},"XState Typegen")," to generate accurate TypeScript types for your machines. And yes, we\u2019re still figuring out typestates."),(0,r.mdx)("li",{parentName:"ul"},"We will update the ",(0,r.mdx)("a",{parentName:"li",href:"https://marketplace.visualstudio.com/items?itemName=statelyai.vscode-xstate"},"XState VS Code extension")," to support XState v5 beta."),(0,r.mdx)("li",{parentName:"ul"},"We will also update ",(0,r.mdx)("a",{parentName:"li",href:"https://stately.ai/editor"},"Stately Studio")," to support importing/exporting XState v5 machines and provide visual tooling for the new features in XState v5 beta, such as machine input/output, partial events, higher-order guards, and more."),(0,r.mdx)("li",{parentName:"ul"},"We\u2019re making the inspector protocol and ",(0,r.mdx)("inlineCode",{parentName:"li"},"@xstate/inspect")," much more flexible to support XState v5 beta and beyond (even other state management libraries).")),(0,r.mdx)("h2",{id:"stately-studio"},"Stately Studio"),(0,r.mdx)("p",null,"Speaking of Stately Studio, besides adding support for XState v5, we\u2019re taking the \u201ceverything is an actor\u201d support to heart. We will be building visual tooling for not just managing actor logic (state machines & statecharts) but also visualization of entire actor systems (architecture diagrams) and the communication between actors (sequence diagrams). This will be a huge step forward for visually understanding and debugging complex systems, and we\u2019re excited to share more about this in the future."),(0,r.mdx)("h2",{id:"we-hope-you-enjoy-xstate-v5-beta"},"We hope you enjoy XState v5 beta!"),(0,r.mdx)("p",null,"We\u2019re excited to see what you build with it (I know everyone says this, but we truly mean it). If you have any questions, feel free to reach out to us on ",(0,r.mdx)("a",{parentName:"p",href:"https://discord.gg/xstate"},"Discord")," or ",(0,r.mdx)("a",{parentName:"p",href:"https://twitter.com/statelyai"},"Twitter"),"."))}u.isMDXComponent=!0}}]);